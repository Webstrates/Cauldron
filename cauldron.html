<!DOCTYPE html>
<html data-protected="all">
    <head>
        <title>Cauldron IDE for Codestrates</title>
        <meta charset="UTF-8">
    </head> 
    <body> 
        <div class="packages">
            <div class="package" id="CauldronNamespace">
                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "Cauldron namespace",
    "description": "Provides the cauldron namespace",
    "dependencies": [],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",    
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <script id="namespace-script" type="disabled">
/**
 * @namespace Cauldron
 */
window.Cauldron = {};

</script>

            </div>

            <div class="package" id="Cauldron">
                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "Cauldron Editor",
    "description": "The base core functionality of Cauldron",
    "dependencies": [
        "wpm_js_libs #cQuery",
        "wpm_js_libs #CaviTouch",
        "wpm_js_libs #golden-layout",
        "wpm_js_libs #golden-layout_material-design-theme",
        "wpm_js_libs #Uploader",
        "webstrate-components-repos #EdgeDocker",
        "webstrate-components-repos #FragmentLogoIcons",
        "webstrate-components-repos #WebstrateIcons",
        "webstrate-components-repos #MaterialDesignOutlinedIcons",
        "webstrate-components-repos #MaterialMenu",
        "webstrate-components-repos #TreeBrowser",
        "webstrate-components-repos #ButtonSystem",
        "webstrate-components-repos #ButtonSystem_MaterialDesign",
        "webstrate-components-repos #RevisionBrowser",
        "webstrate-components-repos #PermissionManager",
        "webstrate-components-repos #WPMPackageBrowser",
        "webstrate-components-repos #HeadEditorComponent",
        "webstrate-components-repos #ModalDialog",
        "codestrates-repos #editor_monaco",
        "#CauldronMainMenu",
        "#CauldronActionMenu",
        "#NewWebstrateActions",
        "#DocumentActions",
        "#CauldronEditorViewActions",
        "#CauldronEditorTabActions",
        "#CauldronInspector",
        "#CauldronConsole",
        "#CauldronEditor",
        "#CauldronNamespace",
        "#CauldronEditorCodestratesActions",
        "#CauldronEditorDocumentation",
        "#CauldronCollaboration",
        "#CauldronSettings"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",    
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <script id="base-script" type="disabled">
/**
 *  Cauldron Base
 *  The core IDE of Cauldron
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global GoldenLayout */

/**
 * Triggered when a Cauldron is opened.
 * @event Cauldron.Cauldron#EventSystem:"Cauldron.OnOpen"
 * @type {CustomEvent}
 * @property {Cauldron.Cauldron} cauldron - The Cauldron that was opened
 */

/**
 * Triggered when a Cauldron is closed.
 * @event Cauldron.Cauldron#EventSystem:"Cauldron.OnClose"
 * @type {Event}
 * @property {Cauldron.Cauldron} cauldron - The Cauldron that was closed
 */

/**
 * Triggered when a Cauldron is initialized.
 * @event Cauldron.Cauldron#EventSystem:"Cauldron.OnInit"
 * @type {Event}
 * @property {Cauldron.Cauldron} cauldron - The Cauldron that was initialized
 */

/**
 * Tirgger to open a FragmentEditor
 * @event Cauldron.Cauldron#EventSystem:"Cauldron.Open.FragmentEditor"
 * @type {Event}
 * @property {Fragment} fragment - The fragment to open in a FragmentEditor
 */

/**
 * The Cauldron editor
 * @memberOf Cauldron
 * @alias Cauldron
 */
class CauldronBase {
    /**
     * Create a new Cauldron editor
     */
    constructor(config={}) {
        let defaultConfig = {
            edgeDockerMode: EdgeDocker.MODE.MINIMIZED,
            edgeDockerLoadMode: true,
            console: true,
            inspector: true,
            actionMenu: true,
            mainMenu: true,
            dragAndDrop: true,
            goldenLayoutSaveState: true
        };

        this.config = Object.assign({}, defaultConfig, config);

        this.setupGoldenLayoutPromise = null;

        //Setup EdgeDocker
        this.docker = new EdgeDocker({
            mode: this.config.edgeDockerMode
        });
        this.docker.getComponentArea().classList.add("cauldron-themeable");
        this.docker.getComponentArea().setAttribute("cauldron-theme", Cauldron.CauldronSettings.getTheme());

        //Setup container divs
        this.editorContentArea = document.createElement("div");
        this.editorContentArea.classList.add("cauldron-base-content");
        this.docker.getComponentArea().appendChild(this.editorContentArea);

        //Setup main menu
        if(this.config.mainMenu) {
            this.topBar = document.createElement("div");
            this.topBar.classList.add("cauldron-base-top");
            this.mainMenu = new CauldronMainMenu();
            this.docker.setupDragHandle(this.mainMenu.html);
        }
        
        // Action menu
        if(this.config.actionMenu) {
            this.actionMenu = new CauldronActionMenu();
            this.topBar.appendChild(this.actionMenu.html);
            this.topBar.appendChild(this.mainMenu.html);
            this.editorContentArea.appendChild(this.topBar);
        }
        
        // Inspector
        if(this.config.inspector) {
            this.inspector = new Cauldron.CauldronInspector();
        }

        //Console
        if(this.config.console) {
            this.console = new Cauldron.CauldronConsole();
        }

        this.goldenLayoutArea = document.createElement("div");
        this.goldenLayoutArea.classList.add("cauldron-layout");
        this.editorContentArea.appendChild(this.goldenLayoutArea);

        this.goldenLayoutInitDone = false;

        //Added components
        this.registeredComponentNames = new Set();

        if(this.config.mainMenu) {
            this.setupMenuItems();
        }

        if(this.config.dragAndDrop) {
            this.setupDragAndDrop();
        }

        this.setupEvents();
    }

    /**
     * Opens Cauldron IDE
     */
    async open() {
        await this.setupGoldenLayout(this.goldenLayoutArea);

        if(this.config.edgeDockerLoadMode) {
            this.docker.loadMode(EdgeDocker.MODE.RIGHT);
        } else {
            this.docker.setMode(EdgeDocker.MODE.RIGHT, false);
        }

        await EventSystem.triggerEventAsync("Cauldron.OnOpen", {
            cauldron: this
        });

        if(!this.goldenLayoutInitDone) {
            let initialisedPromise = new Promise((resolve, reject)=>{
                this.goldenLayout.on("initialised", ()=>{
                    resolve();
                })
            })
            this.goldenLayout.init();
            await initialisedPromise;
            this.goldenLayoutInitDone = true;
            EventSystem.triggerEvent("Cauldron.OnInit", {
                cauldron: this
            });
        }
    }

    /**
     * Closes Cauldron IDE
     */
    close() {
        this.docker.setMode(EdgeDocker.MODE.MINIMIZED);

        EventSystem.triggerEvent("Cauldron.OnClose", {
            cauldron: this
        });
    }

    /**
     * Check wether this Cauldron editor is open
     * @returns {boolean} true/false depending on if Cauldron is open or not
     */
    isOpen() {
        return this.docker.currentMode !== EdgeDocker.MODE.MINIMIZED;
    }

    /**
     * Sets the bounds of this Cauldron
     * @param {Number} x
     * @param {Number} y
     * @param {Number} width
     * @param {Number} height
     */
    setBounds(x, y, width, height) {
        this.docker.setBounds(x, y, width, height);
    }

    /**
     * @private
     */
    setupEvents() {
        let self = this;

        EventSystem.registerEventCallback("Cauldron.ResetLayout", ()=>{
            if(confirm("This will reset Cauldron layout, and reload the page, continue?")) {
                let key = "Cauldron-Saved-State-" + location.pathname.replace(/\//g, "");
                localStorage.setItem(key, null);
                location.reload();
            }
        });

        EventSystem.registerEventCallback("Cauldron.Minimize", ()=>{
            self.close();
        });

        EventSystem.registerEventCallback("Cauldron.Dock", ({detail:{pos: pos}})=>{
            self.docker.setMode(pos);
        });
        
        EventSystem.registerEventCallback("Cauldron.Theme", ({detail:{theme: theme}})=>{
            if (theme){
                self.docker.getComponentArea().setAttribute("cauldron-theme", theme);
            }
        });        

        EventSystem.registerEventCallback("TreeBrowser.TreeNode.Action", ({detail:{node: node, treeBrowser: treeBrowser}})=>{
            if(node.type === "DomTreeNode" && node.context != null && node.context.matches("code-fragment")) {
                let fragment = cQuery(node.context).data("Fragment");

                EventSystem.triggerEvent("Cauldron.Open.FragmentEditor", {
                    fragment: fragment
                });

                return true; //Prevent default event
            }
        });

        EventSystem.registerEventCallback("Cauldron.Open.FragmentEditor", async ({detail: {fragment: fragment, line: line, column:column, editorClass: editorClass, titleWrapper: titleWrapper}})=>{

            if(editorClass == null) {
                editorClass = MonacoEditor;
            }

            if(titleWrapper == null) {
                titleWrapper = (t) => {
                    return t;
                }
            }

            //Make sure cauldron is open?
            if(!this.goldenLayoutInitDone) {
                await new Promise((resolve)=>{
                    EventSystem.registerEventCallback("Cauldron.OnInit", ()=>{
                        //Since goldenLayout has just opened, lets step back and wait a tick
                        setTimeout(()=>{
                            resolve();
                        }, 0);
                    });
                })
            }

            self.createComponent("FragmentEditor", {
                fragment: fragment,
                line: line,
                column: column,
                editorClass: editorClass,
                titleWrapper: titleWrapper
            }, false);
        });

        EventSystem.registerEventCallback("Cauldron.Open.Preview", ({detail: {fragment: fragment}})=>{
            self.createComponent("FragmentEditor", {
                fragment: fragment,
                editorClass: PreviewEditor
            });
        });

        EventSystem.registerEventCallback("Cauldron.Open.InnerHTMLEditor", ({detail: {element: element}}) => {
            self.createComponent("DomElementEditor", {
                element: element
            });
        });
    }

    /**
     * Selects a Golden Layout ContentItem, making it the active item in the Stack it lives inside.
     * @param item - The Golden Layout ContentItem to select
     * @private
     */
    selectItem(item) {
        //Check for stack parent
        if(item.parent != null && item.parent.type === "stack") {
            item.parent.setActiveContentItem(item);
        }
    }

    /**
     * @private
     */
    setupMenuItems() {
        let self = this;

        MenuSystem.MenuManager.registerMenuItem("Cauldron.View", {
            label: "Console",
            icon: IconRegistry.createIcon("mdc:laptop"),
            order: 100,
            onAction: ()=>{
                self.createComponent("Console", {}, false);
            }
        });

        MenuSystem.MenuManager.registerMenuItem("Cauldron.View", {
            label: "Inspector",
            icon: IconRegistry.createIcon("mdc:image_search"),
            order: 101,
            onAction: ()=>{
                self.createComponent("Inspector", {}, false);
            }
        });

        if (typeof webstrate !== "undefined"){
            // Only show revisions and permissions if running in webstrate mode
            MenuSystem.MenuManager.registerMenuItem("Cauldron.File", {
                label: "Revisions...",
                group: "FileMeta",
                groupOrder: 0,
                icon: IconRegistry.createIcon("mdc:restore"),
                order: 0,
                onAction: ()=>{
                    let revisionBrowser = new RevisionBrowser();

                    let dialog = new WebstrateComponents.ModalDialog(revisionBrowser.html, {maximize: true});
                    self.docker.getComponentArea().appendChild(dialog.html);
                    dialog.open();

                    EventSystem.registerEventCallback("RevisionBrowser.OnRestore", (evt)=>{
                        if(evt.detail === revisionBrowser) {
                            dialog.close();
                        }
                    });

                }
            });

            MenuSystem.MenuManager.registerMenuItem("Cauldron.File", {
                label: "Permissions...",
                group: "FileMeta",
                groupOrder: 0,
                icon: IconRegistry.createIcon("mdc:admin_panel_settings"),
                order: 0,
                onAction: ()=>{
                    let pmui = new WebstrateComponents.PermissionManagerUI();
                    pmui.setTopLevelComponent(self.docker.getComponentArea());

                    let dialog = new WebstrateComponents.ModalDialog(pmui.html);
                    self.docker.getComponentArea().appendChild(dialog.html);
                    dialog.open();

                    EventSystem.registerEventCallback("PermissionManagerUI.Saved", (evt)=>{
                        if(evt.detail === pmui) {
                            dialog.close();
                        }
                    });
                }
            });    
        }
        
        MenuSystem.MenuManager.registerMenuItem("Cauldron.File", {
            label: "Properties...",
            group: "FileMeta",
            groupOrder: 0,
            icon: IconRegistry.createIcon("mdc:build_circle"),
            order: 0,
            onAction: ()=>{
                let headEditor = new HeadEditorComponent(false);
                let dialog = new WebstrateComponents.ModalDialog(headEditor.html, {
                    title: "File Properties",
                    actions: {
                        "Close":{primary:true}
                    }
                });
                self.docker.getComponentArea().appendChild(dialog.html);
                dialog.open();

                EventSystem.registerEventCallback("HeadEditorComponent.OnClose", (evt)=>{
                    if(evt.detail === headEditor) {
                        dialog.close();
                    }
                });
            }
        });           
        
        MenuSystem.MenuManager.registerMenuItem("Cauldron.File", {
            label: "Packages...",
            group: "FileMeta",
            groupOrder: 0,
            icon: IconRegistry.createIcon("mdc:extension"),
            order: 0,
            onAction: ()=>{
                let packageBrowser = new WPMPackageBrowser(false);
                packageBrowser.setTopLevelComponent(self.docker.getComponentArea());

                let dialog = new WebstrateComponents.ModalDialog(packageBrowser.html);
                self.docker.getComponentArea().appendChild(dialog.html);
                dialog.open();

                EventSystem.registerEventCallback("WPMPackageBrowser.OnClose", (evt)=>{
                    if(evt.detail === packageBrowser) {
                        dialog.close();
                    }
                });
            }
        });   
    }

    /**
     * Setup golden layout
     * @param {Element} container - The DOM element to use as a container for golden layout
     * @private
     */
    async setupGoldenLayout(container) {
        let self = this;

        if(this.setupGoldenLayoutPromise != null) {
            await this.setupGoldenLayoutPromise;
            return;
        }

        this.setupGoldenLayoutPromise = new Promise(async (resolve)=>{

            await loadGoldenLayout(self.goldenLayoutArea);

            let config = {
                settings: {
                    showPopoutIcon: false,
                    constrainDragToContainer: true
                },
                content: [
                    {
                        type: "row",
                        content: [
                            {
                                type: "column",
                                width: 25,
                                content: [
                                    {
                                        type: 'component',
                                        componentName: 'TreeBrowser',
                                        componentState: {},
                                        isClosable: false
                                    },
                                    {
                                        type: 'component',
                                        height: 25,
                                        componentName: 'Inspector',
                                        componentState: {},
                                        isClosable: true
                                    }
                                ]
                            },
                            {
                                type: "column",
                                width: 75,
                                content: [
                                    {
                                        type: "stack",
                                        id: "editors",
                                        isClosable: false,
                                        content: []
                                    },
                                    {
                                        type: "component",
                                        componentName: "Console",
                                        componentState: {},
                                        height: 25
                                    }
                                ]
                            }
                        ]
                    }
                ]
            };

            if(self.config.goldenLayoutConfig) {
                config = self.config.goldenLayoutConfig;
            }

            if(self.config.goldenLayoutSaveState) {
                let savedState = null;
                try {
                    let key = "Cauldron-Saved-State-" + location.pathname.replace(/\//g, "");

                    savedState = JSON.parse(localStorage.getItem(key), (key, value) => {
                        if (key === "content" && value instanceof Array) {
                            value = value.filter((arrayValue) => {
                                return arrayValue !== null;
                            });

                            //Fix any content with a missing content array?
                            value.forEach((child) => {
                                if (child.content == null) {
                                    child.content = [];
                                }

                                let activeItem = null;

                                if (child.activeItemIndex != null) {
                                    activeItem = child.content[child.activeItemIndex];
                                }

                                //Remove any components that did not deserialize correctly
                                value = value.filter((child) => {
                                    if (child.componentState != null && child.componentState.deserializeSuccess != null && child.componentState.deserializeSuccess !== true) {
                                        return false;
                                    }

                                    return true;
                                });

                                if (child.activeItemIndex != null) {
                                    child.activeItemIndex = Math.max(0, child.content.indexOf(activeItem));
                                }
                            });

                        }

                        if (key === "componentState" && value.serializer != null) {
                            //Use serializer if present
                            value.serializer.serialize = eval(value.serializer.serialize);
                            value.serializer.deserialize = eval(value.serializer.deserialize);
                            value.deserializeSuccess = value.serializer.deserialize(value);
                        }

                        return value;
                    });
                } catch (e) {
                    console.error("Error loading saved state:", e);
                }

                if (savedState != null) {
                    self.goldenLayout = new GoldenLayout(savedState, container);
                } else {
                    self.goldenLayout = new GoldenLayout(config, container);
                }

                let stateChangedTimeoutId = null;

                self.goldenLayout.on('stateChanged', function () {
                    if (stateChangedTimeoutId != null) {
                        clearTimeout(stateChangedTimeoutId);
                        stateChangedTimeoutId = null;
                    }

                    stateChangedTimeoutId = setTimeout(() => {
                        stateChangedTimeoutId = null;
                        let config = self.goldenLayout.toConfig();

                        let cache = [];

                        let key = "Cauldron-Saved-State-" + location.pathname.replace(/\//g, "");

                        localStorage.setItem(key, JSON.stringify(config, (key, value) => {
                            if (key === "componentState" && value.serializer != null) {
                                //Take copy, overriding serializer
                                let clone = Object.assign({}, value, {serializer: {}});
                                delete clone.deserializeSuccess;

                                //Use serializer if present
                                value.serializer.serialize(clone);

                                clone.serializer.serialize = value.serializer.serialize.toString();
                                clone.serializer.deserialize = value.serializer.deserialize.toString();

                                return clone;
                            }

                            return value;
                        }));
                    }, 250);
                });
            } else {
                self.goldenLayout = new GoldenLayout(config, container);
            }

            //Register TreeBrowser
            await self.registerComponent("TreeBrowser", (state)=>{
                let rootNode = new TreeNode({
                    context: null,
                    type: "",
                    hideSelf: true,
                    alwaysOpen: true
                });

                let bodyNode = new DomTreeGenerator().generateTree(document.querySelector("html > body"));
                bodyNode.unfold();
                rootNode.addNode(bodyNode);

                if (typeof webstrate !== "undefined"){
                    // If we are in a webstrate, also show its assets
                    let assetNode = new AssetTreeGenerator().generateTree();
                    assetNode.unfold();
                    rootNode.addNode(assetNode);
                }

                EventSystem.triggerEvent("Cauldron.TreeBrowserSpawned", {
                    root: rootNode
                });           

                let tree = new TreeBrowser(rootNode);

                let treeContainer = document.createElement("div");
                treeContainer.classList.add("cauldron-navigator");
                treeContainer.appendChild(tree.html);

                return treeContainer;
            });

            //Register FragmentEditor
            await self.registerComponent("FragmentEditor", (state)=>{

                const options = {
                };

                if(state.editorClass) {
                    options.editorClass = state.editorClass;
                }

                if(state.titleWrapper) {
                    options.titleWrapper = state.titleWrapper;
                }

                let editorComponent = new Cauldron.CauldronEditor(state.fragment, options);

                return {
                    dom: editorComponent.html,
                    serializer: {
                        serialize: (state)=>{
                            //Serialized needed state into string
                            if(state.fragment != null && typeof state.fragment !== "string") {
                                state.fragment = state.fragment.html[0].__wid;
                            }
                            if(state.editorClass != null && typeof state.editorClass !== "string") {
                                state.editorClass = state.editorClass.prototype.constructor.name;
                            }
                            if(state.titleWrapper != null && typeof state.titleWrapper === "function") {
                                state.titleWrapper = state.titleWrapper.toString();
                            }
                            if(state.line) {
                                delete state.line;
                            }
                        },
                        deserialize: (state)=>{
                            //Deserialize state, and return true/false if success
                            state.fragment = Fragment.find("code-fragment").find((frag)=>{
                                return frag.html[0].__wid === state.fragment;
                            });

                            if(state.editorClass != null) {
                                state.editorClass = window[state.editorClass];
                            }

                            if(state.titleWrapper != null) {
                                state.titleWrapper = eval(state.titleWrapper);
                            }

                            return state.fragment != null;
                        }
                    },
                    onResize: ()=>{
                        editorComponent.onSizeChanged();
                    },
                    onShow: ()=>{
                        //On show is called right before the container is actually shown?
                        setTimeout(()=>{
                            editorComponent.onSizeChanged();
                            editorComponent.focus();
                            if(state.line != null) {
                                if (state.column!=null){
                                    editorComponent.setLine(state.line, state.column);
                                } else {
                                    editorComponent.setLine(state.line);
                                }
                                //Only do this once
                                delete state.line;
                                delete state.column;
                            }
                        }, 0);
                    },
                    onTab: (tab)=>{
                        let lastTitle = null;
                        let lastTooltop = null;

                        function updateTab() {
                            if(lastTooltop !== editorComponent.tooltip || lastTitle !== editorComponent.title) {
                                tab.element[0].title = editorComponent.tooltip;
                                tab.titleElement[0].innerText = editorComponent.title;

                                tab.titleElement.find(".cauldron-editor-tab-icon").remove();
                                let icon = IconRegistry.createIcon(["code-fragment:" + state.fragment.type, "mdc:insert_drive_file"]);
                                icon.classList.add("cauldron-editor-tab-icon");
                                if (icon) {
                                    tab.titleElement.prepend(icon);
                                }
                                
                                // Setup context menu for tab
                                tab.element[0].addEventListener("contextmenu", (e)=>{
                                    e.preventDefault();
                                });
                                tab.element[0].addEventListener("mouseup", (e)=>{          
                                    if(e.button !== 2) {
                                       return;
                                    }
                                    let contextMenu = MenuSystem.MenuManager.createMenu("Cauldron.Tab.ContextMenu", {
                                        context: {tab:tab, editor:editorComponent},
                                        groupDividers: true
                                    });        
                                    contextMenu.registerOnCloseCallback(()=>{
                                        if(contextMenu.html.parentNode != null) {
                                            contextMenu.html.parentNode.removeChild(contextMenu.html);
                                        }
                                    });      

                                    //Find top component after html
                                    let parent = tab.element[0];
                                    while(parent.parentNode != null && !parent.parentNode.matches("html")) {
                                        parent = parent.parentNode;
                                    }
                                    parent.appendChild(contextMenu.html);
                                    contextMenu.open({
                                        x: e.pageX,
                                        y: e.pageY
                                    });
                                    e.stopPropagation();
                                    e.preventDefault();
                                });

                                lastTooltop = editorComponent.tooltip;
                                lastTitle = editorComponent.title;
                            }
                        }

                        state.fragment.registerOnFragmentChangedHandler(()=>{
                            updateTab();
                        });

                        updateTab();
                    },
                    onDestroy: ()=>{
                        editorComponent.destroy();
                    }
                };
            });

            //Register innerHTML editor
            await self.registerComponent("DomElementEditor", (state)=>{
                let element = state.element;

                let fragmentType = "text/html";
                let tabTitle = "Dom HTML";

                if(element.matches("style")) {
                    fragmentType = "text/css";
                    tabTitle = "Dom CSS";
                } else if(element.matches("script[type='text/javascript'], script:not([type])")) {
                    fragmentType = "text/javascript";
                    tabTitle = "Dom JS";
                }

                let fakeFragment = Fragment.create(fragmentType);
                fakeFragment.raw = element.innerHTML;

                fakeFragment.supportsAuto = ()=>{
                    return false;
                };

                fakeFragment.supportsRun = ()=>{
                    return false;
                };

                if(fragmentType === "text/css" || fragmentType === "text/javascript") {
                    //Setup direct editing of style / script

                } else {
                    fakeFragment.isInnerHtmlEditor = true;

                    //Indirect editing with save button for the rest
                    fakeFragment.save = ()=>{
                        let test = document.createElement(element.tagName.toLowerCase());
                        test.innerHTML = fakeFragment.raw;

                        if(test.innerHTML != fakeFragment.raw) {
                            if(!confirm("Your HTML does not parse correctly, the browser did some change, sure you want to save?")) {
                                return false;
                            }
                        }

                        element.innerHTML = fakeFragment.raw;

                        editorComponent.southArea.classList.remove("unsaved-changes");
                    };
                }

                let observer = null;

                let removed = false;

                const options = {
                    editorClass: MonacoEditor
                };

                if(state.editorClass) {
                    options.editorClass = state.editorClass;
                }

                if(state.titleWrapper) {
                    options.titleWrapper = state.titleWrapper;
                }

                let editorComponent = new Cauldron.CauldronEditor(fakeFragment, options);

                if(fragmentType === "text/css" || fragmentType === "text/javascript") {
                    //Read back changes into dom
                    fakeFragment.registerOnFragmentChangedHandler(()=>{
                        if(!removed && element.parentNode != null) {
                            observer.disconnect();
                            if (element.firstChild instanceof Text) {
                                element.firstChild.nodeValue = fakeFragment.raw;
                            } else {
                                element.textContent = fakeFragment.raw;
                            }
                            setTimeout(() => {
                                startObserver();
                            }, 0);
                        }
                    });
                } else {
                    //Setup direct editing of style / script
                    let oldHandleModelChanged = editorComponent.editor.handleModelChanged;

                    editorComponent.editor.handleModelChanged = function() {
                        oldHandleModelChanged.bind(editorComponent.editor)();

                        //Model changed, warn user
                        editorComponent.southArea.classList.add("unsaved-changes");
                    };

                    editorComponent.html.addEventListener("keyup", (evt)=>{
                        if(evt.key === "s" && evt.ctrlKey) {
                            fakeFragment.save();
                        }
                    });
                }

                observer = new MutationObserver((mutations)=>{
                    mutations.forEach((mutation)=>{
                        Array.from(mutation.removedNodes).forEach((removedNode)=>{
                            if(removedNode === element) {
                                fakeFragment.unload();
                                observer.disconnect();
                                removed = true;
                            }
                        });

                        if(!removed) {
                            if (fragmentType === "text/css" || fragmentType === "text/javascript") {
                                if (element.firstChild instanceof Text) {
                                    fakeFragment.raw = element.innerHTML;
                                } else {
                                    fakeFragment.raw = element.textContent;
                                }
                            }
                        }
                    });
                });

                function startObserver() {
                    observer.observe(element.parentNode, {
                        childList: true,
                        characterData: true,
                        subtree: true
                    });
                }

                startObserver();

                return {
                    dom: editorComponent.html,
                    serializer: {
                        serialize: (state)=>{
                            //Serialized needed state into string
                            if(state.element != null && typeof state.element !== "string") {
                                state.element = state.element.tagName+":"+state.element.__wid;
                            }
                        },
                        deserialize: (state)=>{
                            //Deserialize state, and return true/false if success
                            let split = state.element.split(":");
                            state.element = Array.from(document.querySelectorAll(split[0])).find((elm)=>{
                                return elm.__wid === split[1];
                            });

                            return state.element != null;
                        }
                    },
                    onTab: (tab)=>{
                        tab.titleElement[0].innerText = tabTitle+": "+element.tagName.toLowerCase();
                    },
                    onShow: ()=>{
                        //On show is called right before the container is actually shown?
                        setTimeout(()=>{
                            editorComponent.onSizeChanged();
                        }, 0);
                    },
                    onDestroy: (container)=>{
                        if(fragmentType === "text/css" || fragmentType === "text/javascript") {

                        } else {
                            if (editorComponent.southArea.classList.contains("unsaved-changes")) {
                                if (confirm("You have unsaved changes, save them now?")) {
                                    fakeFragment.save();
                                }
                            }
                        }
                    }
                };
            });

            //Register Inspector
            await self.registerComponent("Inspector", (state)=>{
                return self.inspector.html;
            });

            //Register Console
            await self.registerComponent("Console", (state)=>{
                return self.console.html;
            });

            window.addEventListener("resize", ()=>{
                let bounds = self.editorContentArea.getBoundingClientRect();

                let topBarHeight = 0;

                if(self.topBar != null) {
                    let topBarBounds = self.topBar.getBoundingClientRect();
                    topBarHeight = topBarBounds.height;
                }
                self.goldenLayout.updateSize(bounds.width, bounds.height - topBarHeight);
            });

            resolve();
        });

        await this.setupGoldenLayoutPromise;
    }

    hasComponent(componentName) {
        return this.registeredComponentNames.has(componentName);
    }

    /**
     * This callback is used to create components
     * @callback Cauldron.Cauldron~creatorCallback
     * @param {object} state - The state of the component
     * @returns {Cauldron.Cauldron~creatorCallbackResult|Element}
     */

    /**
     * This object is used to describe the serialize / deserialize of component state that cannot serialize correctly
     * using only JSON stringify/parse.
     * @typedef {object} Cauldron.Cauldron~serializer
     * @property {Function} serialize
     * @property {Function} deserialize
     */

    /**
     * Represents the result of a component creator function
     * @typedef {object} Cauldron.Cauldron~creatorCallbackResult
     * @property {Element} dom - The dom element of the component
     * @property {Cauldron.Cauldron~serializer} [serializer] - Serializer to use when state cannot serialize correctly using JSON stringify/parse
     * @property {Cauldron.Cauldron~componentResizedCallback} [onResize] - Callback that is called when component is resized
     * @property {Cauldron.Cauldron~tabCreatedCallback} [onTab] - Callback that is called when component has a tab created
     * @property {Cauldron.Cauldron~componentDestroyCallback} [onDestroy] - Callback that is called when component is destroyed
     * @property {Cauldron.Cauldron~componentShowCallback} [onShow] - Callback that is called when component is shown
    */

    /**
     * @callback Cauldron.Cauldron~componentShowCallback
     * @param {object} container - The Golden Layout container
     */

    /**
     * @callback Cauldron.Cauldron~componentResizedCallback
     * @param {object} container - The Golden Layout container
     */

    /**
     * @callback Cauldron.Cauldron~componentDestroyCallback
     * @param {object} container - The Golden Layout container
     */

    /**
     * @callback Cauldron.Cauldron~tabCreatedCallback
     * @param {object} tab - The tab that was created
     * @param {object} container - The Golden Layout container
     */

    /**
     * Register a component with Cauldron
     *
     * @example
     * registerComponent("MyComponent", (state)=>{
     *     let myComponentDom = document.createElement("div");
     *     myComponentDom.textContent = state.someState;
     *
     *     return myComponentDom;
     * });
     *
     * @example
     * registerComponent("MyComponent", (state)=>{
     *     let myComponentDom = document.createElement("div");
     *     myComponentDom.textContent = state.someState;
     *
     *     return {
     *         dom: myComponentDom,
     *         onResize: ()=>{
     *             //The component has been resized, do something
     *         },
     *         onTab: (tab)=>{
     *             //The component has created a tab, do something to it
     *         },
     *         onShow: ()=>{
     *             //Called when the component is made visible, ie. its tab is switched to
     *         },
     *         onDestroy: ()=>{
     *             //Called when the component is destroyed
     *         }
     *     };
     * });
     *
     * @example
     * registerComponent("MyComponent", (state)=>{
     *     let myComponentDom = document.createElement("div");
     *     myComponentDom.textContent = state.someState;
     *
     *     return {
     *         dom: myComponentDom,
     *
     *         //Setup serializer to handle state that cannot JSON stringify/parse correctly
     *         serializer: {
     *             serialize: (state)=>{
     *                 //Serialize all state that cannot JSON stringify/parse correctly
     *             },
     *             deserialize: (state)=>{
     *                 //Deserialize all state that cannot JSON stringify/parse correctly
     *             }
     *         }
     *     };
     * });
     *
     * @param {String} componentName - The name of the component
     * @param {Cauldron.Cauldron~creatorCallback} creator
     */
    async registerComponent(componentName, creator) {
        if(this.hasComponent(componentName)) {
            //Already registered
            return;
        }

        if(this.goldenLayout == null) {
            await this.setupGoldenLayout(this.goldenLayoutArea);
        }

        this.registeredComponentNames.add(componentName);

        await this.goldenLayout.registerComponent(componentName, function(container, state) {
            try {
                let componentConfig = creator(state, container);

                if(componentConfig.serializer != null) {
                    state.serializer = componentConfig.serializer;
                    container.setState(state);
                }

                if(componentConfig instanceof Element) {
                    container.getElement()[0].appendChild(componentConfig);
                    componentConfig.glContainer = container;
                } else {
                    container.getElement()[0].appendChild(componentConfig.dom);
                    componentConfig.dom.glContainer = container;

                    if(componentConfig.onResize != null) {
                        container.on("resize", () => {
                            componentConfig.onResize(container);
                        });
                    }

                    if(componentConfig.onShow != null) {
                        container.on("show", () => {
                            componentConfig.onShow(container);
                        });
                    }

                    if(componentConfig.onTab != null) {
                        container.on("tab", (tab) => {
                            componentConfig.onTab(tab, container);
                        });
                    }

                    if(componentConfig.onDestroy != null) {
                        container.on("destroy", () => {
                            componentConfig.onDestroy(container);
                        });
                    }
                }
            } catch(e) {
                console.error("Error creating component:", e);
                let errorDiv = document.createElement("div");
                errorDiv.innerHTML = "Something broke!";
                container.getElement()[0].appendChild(errorDiv);
                errorDiv.glContainer = container;
            }
        });
    }

    /**
     * Create a component with the given name and state
     *
     * @example
     * createComponent("MyComponent", {
     *     someState: "ImportantStateData"
     * });
     *
     * @param {String} componentName
     * @param {object} [state]
     * @param {boolean} [allowMultipleInstances=false] - Determines if multiple components with the same state are allowed, if set to true a new component will always be created. If false and a component with the same state already exists, then that component will be selected instead.
     */
    async createComponent(componentName, state = {}, allowMultipleInstances = false) {
        if(!allowMultipleInstances) {
            function compare(obj1, obj2) {
                //Check if these are equal
                if (Object.is(obj1, obj2)) {
                    return true;
                }

                //Check if both are same type
                if (typeof obj1 !== typeof obj2) {
                    return false;
                }

                //Since both were not equal, if one is null or undefined the other by definition is not
                if (obj1 == null || obj2 == null) {
                    return false;
                }

                //Handle object
                if (typeof obj1 === "object") {

                    //Only deep compare objects that are of constructor Object or Array
                    if(obj1.constructor.name !== obj2.constructor.name) {
                        return false;
                    }

                    if(obj1.constructor.name !== "Array" && obj1.constructor.name !== "Object") {
                        //We already tested that constructor names are equal, and only want Array or Object
                        return false;
                    }

                    for (let key in obj1) {
                        if(obj1.hasOwnProperty(key)) {
                            let obj1Value = obj1[key];
                            let obj2Value = obj2[key];

                            if (!compare(obj1Value, obj2Value)) {
                                return false;
                            }
                        }
                    }

                    for (let key in obj2) {
                        if(obj2.hasOwnProperty(key)) {
                            //Property existed in obj2 but not in obj1, everything else has already been tested
                            if (typeof obj1[key] === "undefined") {
                                return false;
                            }
                        }
                    }

                    return true;
                }

                if(typeof obj1 === "function") {
                    let equals = obj1.toString() === obj2.toString();

                    return equals;
                }

                //Nothing else failed, equal i guess?

                return true;
            }

            //Check for already present editor
            let foundComponents = this.goldenLayout.root.getItemsByFilter((item) => {
                if (item.componentName === componentName) {
                    let componentState = item.container.getState();

                    //Remove all our serializer stuff from state before comparing
                    let compareClone1 = Object.assign({}, componentState, {
                        componentName: null,
                        deserializeSuccess: null,
                        serializer: {},
                        line: null,
                        column: null
                    });
                    let compareClone2 = Object.assign({}, state, {
                        componentName: null,
                        deserializeSuccess: null,
                        serializer: {},
                        line: null,
                        column: null
                    });

                    let equal = compare(compareClone1, compareClone2);

                    return equal;
                }
            });

            if (foundComponents.length > 0) {
                //Attempt to update state
                foundComponents[0].config.componentState = Object.assign(foundComponents[0].config.componentState, state);

                //Select the already found component
                this.selectItem(foundComponents[0]);
                return;
            }
        }

        this.goldenLayout.root.getItemsById("editors")[0].addChild({
            type: "component",
            componentName: componentName,
            componentState: state
        });
    }

    /**
     * @private
     */
    setupDragAndDrop() {
        function addAssetToDescriptor(descFrag, assetFileName) {
            if(descFrag != null) {
                descFrag.require().then((descJson)=>{
                    if(!descJson.assets.includes(assetFileName)) {
                        descJson.assets.push(assetFileName);
                        descFrag.raw = JSON.stringify(descJson, null, 2);
                    }
                });
            }
        }

        EventSystem.registerEventCallback("TreeBrowser.TreeNode.Dropped", ({detail: { draggedNode: draggedNode, droppedNode: droppedNode, dropEffect: dropEffect, dragEvent: dragEvent}})=>{
            if(draggedNode.type === "DomTreeNode" && droppedNode.type === "DomTreeNode") {
                if(dragEvent.altKey && dropEffect === "move") {
                    //Move to before target
                    droppedNode.context.parentNode.insertBefore(draggedNode.context, droppedNode.context);
                } else if(!droppedNode.context.matches("code-fragment")) {
                    try {
                        if(dropEffect === "move") {
                            //Move inside target
                            droppedNode.context.appendChild(draggedNode.context);
                        } else if(dropEffect === "copy") {
                            let clone = draggedNode.context.cloneNode(true);
                            WPMv2.stripProtection(clone);
                            droppedNode.context.appendChild(clone);
                        }
                        droppedNode.unfold();
                    } catch(e) {
                        //Hide errors
                        console.error(e);
                    }
                }
            }

            if(draggedNode.type === "AssetNode" && droppedNode.type === "DomTreeNode") {
                let descFrag = cQuery(droppedNode.context.querySelector("code-fragment[data-type='wpm/descriptor']")).data("Fragment");

                addAssetToDescriptor(descFrag, draggedNode.context.fileName);
            }

            if(draggedNode.type === "AssetNode" && droppedNode.type === "AssetRootNode") {
                let parentNode = droppedNode.parentNode;
                if(parentNode != null && parentNode.type === "DomTreeNode" && parentNode.context.matches("wpm-package")) {

                    let descFrag = cQuery(parentNode.context.querySelector("code-fragment[data-type='wpm/descriptor']")).data("Fragment");

                    addAssetToDescriptor(descFrag, draggedNode.context.fileName);
                }
            }
        });

        EventSystem.registerEventCallback("TreeBrowser.DomFragment.Dropped", ({detail: { fragment: fragment, droppedNode: droppedNode, otherWebstrate: otherWebstrate}})=>{
            if(droppedNode.type === "DomTreeNode") {
                let firstChild = fragment.firstChild;
                let descriptors = fragment.querySelectorAll("code-fragment[data-type='wpm/descriptor']");
                droppedNode.context.appendChild(fragment);
                if(otherWebstrate != null && otherWebstrate !== location.href) {
                    //Let fragment stuff complete
                    setTimeout(() => {
                        descriptors.forEach((desc) => {
                            let frag = Fragment.one(desc);
                            frag.require().then((descJson) => {
                                descJson.assets.forEach((asset) => {
                                    fetch(otherWebstrate + asset).then((response) => {
                                        response.blob().then((blob) => {
                                            Uploader.upload(location.href, blob, asset).then(() => {
                                                frag.triggerFragmentChanged(frag);
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    }, 0);
                }

                setTimeout(()=>{
                    //unfold the node we dropped into
                    TreeBrowser.findAllTreeBrowsers().forEach((tb)=>{
                        tb.findTreeNodeForContext(firstChild.parentNode).forEach((treeNode)=>{
                            treeNode.unfold();
                        });
                    });
                }, 0);
            }
        });

        EventSystem.registerEventCallback("TreeBrowser.Asset.Dropped", async ({detail: { assetUrl: assetUrl, droppedNode: droppedNode}})=>{
            let assetName = assetUrl.substring(assetUrl.lastIndexOf("/")+1);

            if(droppedNode.type === "AssetNode" || droppedNode.type === "AssetRootNode" || droppedNode) {
                let parentNode = droppedNode.parentNode;

                fetch(assetUrl).then((response)=>{
                    response.blob().then((blob)=>{
                        Uploader.upload(location.href, blob, assetName).then(()=>{
                            if(parentNode != null && parentNode.type === "DomTreeNode" && parentNode.context.matches("wpm-package")) {

                                let descFrag = cQuery(parentNode.context.querySelector("code-fragment[data-type='wpm/descriptor']")).data("Fragment");
                                addAssetToDescriptor(descFrag, assetName);
                            }
                        });
                    });
                });
            }

            if(droppedNode.type === "DomTreeNode" && droppedNode.context.matches("wpm-package")) {
                let descFrag = cQuery(droppedNode.context.querySelector("code-fragment[data-type='wpm/descriptor']")).data("Fragment");
                if(descFrag != null) {
                    fetch(assetUrl).then((response)=> {
                        response.blob().then((blob) => {
                            Uploader.upload(location.href, blob, assetName).then(() => {
                                addAssetToDescriptor(descFrag, assetName);
                            });
                        });
                    });
                }
            }
        });

        EventSystem.registerEventCallback("TreeBrowser.Files.Dropped", async ({detail: { files: files, droppedNode: droppedNode}})=>{
            if(droppedNode.type === "AssetNode" || droppedNode.type === "AssetRootNode") {
                let parentNode = droppedNode.parentNode;

                for(let file of Array.from(files)) {
                    await Uploader.upload(location.href, file, file.name);
                    if(parentNode != null && parentNode.type === "DomTreeNode" && parentNode.context.matches("wpm-package")) {

                        let descFrag = cQuery(parentNode.context.querySelector("code-fragment[data-type='wpm/descriptor']")).data("Fragment");

                        addAssetToDescriptor(descFrag, file.name);
                    }
                }
            }

            if(droppedNode.type === "DomTreeNode" && droppedNode.context.matches("wpm-package")) {
                let descFrag = cQuery(droppedNode.context.querySelector("code-fragment[data-type='wpm/descriptor']")).data("Fragment");
                if(descFrag != null) {
                    for(let file of Array.from(files)) {
                        await Uploader.upload(location.href, file, file.name);
                        addAssetToDescriptor(descFrag, file.name);
                    }
                }

            }
        });

        EventSystem.registerEventCallback("TreeBrowser.TreeNode.DragOver", ({detail: {node: node, dragEvent: evt}})=>{

            let defaultDropEffect = false;
            let handled = false;

            if(node.type === "DomTreeNode") {
                if(evt.dataTransfer.types.includes("Files")) {
                    if(node.context.matches("wpm-package")) {
                        let descFrag = cQuery(node.context.querySelector("code-fragment[data-type='wpm/descriptor']")).data("Fragment");
                        if(descFrag != null) {
                            evt.dataTransfer.dropEffect = "copy";
                            handled = true;
                        }
                    }
                } else if(evt.dataTransfer.types.includes("treenode/uuid")){
                    let dragUUID = null;

                    evt.dataTransfer.types.forEach((type)=>{
                        if(type.indexOf("treenodedata/uuid") !== -1) {
                            dragUUID = type.split("|")[1];
                        }
                    });


                    let dragged = document.querySelector("[transient-drag-id='" + dragUUID + "']");
                    if (dragged != null && dragged.treeNode != null) {
                        handled = true;
                        if(dragged.treeNode.type === "DomTreeNode" ) {
                            if(evt.altKey) {
                                //We are insertingBefore, not appending, only non allowed action is wpm-package inside wpm-package?
                                let draggedIsWpmPackage = dragged.treeNode.context.matches("wpm-package") || dragged.treeNode.context.querySelector("wpm-package") != null;
                                let droppedIsInsideWpmPackage = !node.context.matches("wpm-package") && node.context.closest("wpm-package") != null;

                                let droppedIsBody = node.context.matches("body");

                                if(!droppedIsBody && (!droppedIsInsideWpmPackage || !draggedIsWpmPackage)) {
                                    defaultDropEffect = true;
                                }
                            } else if(!node.context.matches("code-fragment, wpm-package") && node.context.closest("wpm-package") == null) {
                                //We are not dragging inside code-fragment or wpm-package
                                if (!dragged.treeNode.context.contains(node.context)) {
                                    defaultDropEffect = true;
                                }
                            } else if(node.context.matches("wpm-package")) {
                                //We are dragging into a wpm-package, make sure we dont ourselves include a wpm-package
                                if(!dragged.treeNode.context.matches("wpm-package") && dragged.treeNode.context.querySelector("wpm-package") == null) {
                                    defaultDropEffect = true;
                                }
                            }
                        } else if(dragged.treeNode.type === "AssetNode") {
                            if(node.context.matches("wpm-package")) {
                                let descFrag = cQuery(node.context.querySelector("code-fragment[data-type='wpm/descriptor']")).data("Fragment");
                                if(descFrag != null) {
                                    evt.dataTransfer.dropEffect = "copy";
                                }
                            }
                        }
                    }
                }

                if(!handled && evt.dataTransfer.types.includes("text/plain")) {
                    if(!node.context.matches("code-fragment")) {
                        defaultDropEffect = true;
                    }
                }
            } else if(node.type === "AssetRootNode") {
                if(evt.dataTransfer.types.includes("Files") || evt.dataTransfer.types.includes("treenode/asset")) {
                    evt.dataTransfer.dropEffect = "copy";
                }
            }

            if(defaultDropEffect) {
                if(evt.ctrlKey) {
                    evt.dataTransfer.dropEffect = "copy";
                } else {
                    evt.dataTransfer.dropEffect = "move";
                }
            }
        });
    }
}

window.Cauldron.Cauldron = CauldronBase;

</script>

                <style id="main-style">
/**
 *  Base Cauldron Styles
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
@keyframes cauldron-logo-appears {
  0% {
    transform: scale(0) translateY(-5%) scaleX(6);
    opacity: 0; }
  100% {
    transform: scale(0.5) translateY(-5%);
    opacity: 0.08; } }

@keyframes cauldron-content-appears {
  0% {
    opacity: 0; }
  100% {
    opacity: 1; } }

.cauldron-navigator {
  overflow-y: auto;
  height: 100%;
  overflow-x: hidden; }

.cauldron-base-top {
  background: #8484840f;
  border-bottom: 1px solid rgba(100, 100, 100, 0.1);
  display: flex;
  flex-direction: row-reverse;
  justify-content: space-between;
  flex: 0 0 auto; }

.cauldron-base-content {
  display: flex;
  flex-direction: column;
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  overflow: hidden;
  background: var(--mdc-theme-background, #FFFFFF);
  color: var(--mdc-theme-text-primary-on-background, black);
  font-family: sans-serif; }
  .cauldron-base-content .cauldron-layout {
    flex: 1 1 auto; }
    .cauldron-base-content .cauldron-layout .lm_goldenlayout {
      background: none; }
    .cauldron-base-content .cauldron-layout .lm_title {
      height: 100%;
      margin-bottom: -5px; }
      .cauldron-base-content .cauldron-layout .lm_title .cauldron-editor-tab-icon {
        width: 1em;
        height: 100%;
        vertical-align: text-bottom;
        padding-right: 0.3em; }
    .cauldron-base-content .cauldron-layout .lm_tab {
      margin-right: 1px;
      padding-left: 0.3em;
      padding-right: 20px;
      display: flex; }
    .cauldron-base-content .cauldron-layout .lm_content {
      animation: 0.15s cauldron-content-appears ease-in; }
    .cauldron-base-content .cauldron-layout .lm_items:empty {
      position: relative; }
      .cauldron-base-content .cauldron-layout .lm_items:empty:after {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        content: "";
        background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAKAAQMAAAA2A1tgAAAABlBMVEUAAAAAAAClZ7nPAAAAAXRSTlMAQObYZgAADihJREFUeNrsnDGO3SAURT1x4dJL8DbSeWORzNJYCl1a0lEgiCKPfSBEjs17UlLYzfz/mX8E3AtcsGeG41r8oHstOWoDc9AGZqsNzOpArw3M6kCvDczqQKcMVHX3TrSaRG3njL+ASd3cdlBudNAEzrRZsYpWu4peu4pRfZ41g7IXnWoVN+21ZdY2zgedqNdmp93mMCjrnAbtNquHEqsKnHL22saJ2p2Y1DvRaHei0+5Er9BOV3Zi1Og4W7xOKkqUnWg0gL4YzlZ3MUFmEZAqrjmoADNvogaQhk6wZy8BRqxtzu60AmCJkU49c5Vf1+zOxmdJfo1nfQNA173c0eb5QM+SCLpRmzEnujYK5sEcTy1Ke0qqeL60AI0kvzpkLvzee6HAkj1ALxl/6ejPADCI8qv5fBXxUhBldvcpcwIYNQ5bcj6tlJNoSY6Hb8wJzLJ9Cqvg3quyjLweE9ecnQaQLDftPz/Y5guz3PipDkBBltvJEaDTyHKf4A2gMMttWQVIllt1akiWWyJAQVwky81hr6gQSJabvAqQLDc6JeCQP8eI1QGS5YxM5cU3CVsIzBZVdIBtlmNykG1qqZEQGE9VPCORCbZnF0CWw5UCIJkw/QbsjcTpgEBgGZUcl9JGFvo+YCDL8XEn8IO2IbMoLI20eQYhmRuWzJocZSOPRscisktWUZpXRC9JcKAXLTJLBgod5onsCmluzmcQ9sKBQo8R2XcywM42WyI7A0XSZn9EdnwdRGtywDcaQeTosDWb1tcfpj8dLtm2vl5CV7CxRWSfKuCW+tPhdHCbk43nxgm7OoajEhTzPRNE2muKaxLdEXucuKMSrokIlvvT4TdcE5jdHnciOeQrrvHloUmPKp7qAvyk+/4Uhg0d9OfDmhyCDW1Bj12qNCd2sqlxJ2DDXL/pUcXysqjU1gtckLK6a597gOQQbBgQuQtIDqltOAGcHvmb9QQbYqGMVZ/I/CcbrgDv31bjCKi14Qbw6SSx1pWqRE6fWrlnMrvShpXI8RMYnsnsWxtOAMdnY5ojIGyIyOETmJ75JpY2rET2x+fPfJNKG1Yi2y7glo9WAsz7ZQ6geeYbgw1tKXJm/9GxuV+POiFyAthhRCZAHkA6ga7DiGedEDkAfG7Ej7NOiMwpqn9oxON7eByFngOHHE8dfCWy6QRuARuWAy/3rvirx4aVyL3AxWJDRKZDHwNngw3Lged7gRM2rER2vU3+8psNJ1zTB8QpoRZZAMSGaJIkQGzIwIsSIDZEkyABYkM08RIgNkQTKwBiQzTJBrmeAmsbZlwDsNuGaJIkQGyIJlEGxIYLrqHI9/naogmMuQdI2EQTKwKuVVCA3gkkbGLrTOW7gZG67nTBXXZ03XBNN5C9PLbGeetTIEo4bL3TpUCLrXcEQNs1UFhNS8T2FIhX6MKdLgWmsguz5B4QR6V0YaqBpgcYyi6MEiD3FOjCUFv0GQ6v0YUe4PPjFpRcc2PDUQKkxcg6Pj9hwhq0GBWmfqBBY1RgjeoAjvAAzo+BnF8v8FIN9F3AAI9OE8yv1RW0gX4QTYdjidr+ADQCoFnrNm5CYOI2bOGooR8YeHwOYBIA3Q5ELynQDmsLjB2BmBGyUqXeyF5P1CtVkkR25tUNIEO5G2h2YADYd3+YOWEHeunfUpUriWgoM76Y+KUjr9nQykceOdgdAlnRQAF4IoxkoLBNCQBFA6XeSI3yRZTVHKBgoEBxJzv1LlFcUADi6yfDlzNS1wJbX0/MStdAbiTN+IS0+RjIBZBwqAREfTkw1NFLBlz4dfbKGkBEdkpAorISENfoAHGNELjy6zynpgFkC6gEZAuoCGSTJgfyO0YPOOEaMRCRkw4QTaIikB2LFBjL4yY1IKdDcmAq/+WDHnCjXDrbZLow6AANfzymA7RnCLU6QH9+1QiBTKobxQrA/IMvagC5vBw4VUCrDRxkQPxMqQhIAd/TBToF4FACjQZwq7tQDlwBBhXgAtCpAGeAgwoQZ0cdIM52OkCMaBSAzV0pORCZnQ4QmQcVIEVBCch6pwck/MuBlFk1IH/wKgdC9IMOkOsFvsAX+AJf4At8gf8QuOagB2zu5rXhyTwELvlvAekZcLzqUBD3getFrOaRzvvAMV8Ef8ruA9kv2raClN0GjvliN1aU3Qaumcu0ElPFm8CPq4OaLXPFm8D66Ofq0MXcAvIw42/OQS77+dPfAo61e9LFU3/pFpC78Lysz/7oTHsHSHlzN/mjeRL9BnDCLFSxfOvKNzeAK8VUsXiXqnff/wrEzahqedM88nALGH/zXarmQSS/Cax13bhZ33xzvQlM7eQSzvqYZthcA9vhy+ftF7d7QFMVLBdnsPMtYGwLrsuuge06srYVpOwOsD37uj7TvQa2RdcrzA2ga4su1sD170A+QmjV0zn85hTjHH6XAmm1+e8C5wt8gS/wBb7AF/iTfTvIgRqEwgD8CAt2snXHTeRKLl0YIXHhMbwKxgN4BbwBS4yE39JOhToulIeJi85mAn18Ydo+mLy0N3iDN/gHoAqLQZMWgzYvBl1ZDKL+9yAWg241aFeDBn4l+Ir0UlCA1ACayAXlFXSZCypsZuhgXQ2CBdrYQLEORPoVtPAMUCKTvoKGBaoDpH8JahaoG1iXgoXMFTSgBaBbBcpnsDVfTYP0DNq9KfIkaMtDGHsIUVYGWC6gKySQFCZB8wQik2yg54H+kt0NDItAsYEaUTJAdwElIhmEeTD/BrTw60C1Sa6BkQViSMZAAHFAXEADL1CXgi3BF4IWG5A5oGhgHbdlzQHtDooBLGSQNjAsAlHIInJA2cDSQzI5BC4oBzAR4DfEs8DcMy8JJqg2UOU+OEqgfRMLTEPmqXZcc8BKegTNDtZpUKOSiUMqWxQmiAG0INdGmjILJvMFZEPflQW44Ad4F3oqSyC1mU+CLtkP+ATfU1ntoEvzoAQw7MrmGyKRi9Og+wV0XxuIefCdHDvwDZ8QSCBMg1UApYNAwyT8NFjEGApUuYM0C34rBKQhIrfZqToNfs/khisAxAbqMg0ik0UYQN9Ak+fBRAaX+kgDbeKAOg/tvIMuzoPxEmL3DU8gzIPhEvKCGqjg2eAYFU2lWdDCP0dlFAb426g8D1Z6+rBeNza/AR3g58HyO7DSNKjTM2iQ50EZn0GFuLiO/e7/K4zf4A3e4A3e4A3e4A3+FejiYhB5LSieH4CtLFA+Ot8MwZ43w7q7/ZBE4INjUU4hckBqndYPoEZiga4SISiEDmYWaBsYL2BhgaaSQJQLwUKygbGDlQ+GAZR8UCGIDhLAAm0mDT+CdjVo4Dmgy5tAI6iZYCJ7BRUCF6wD+JIkD0QiN4Jv2WAklKEQueMMUDQwd1BWIiYYxAiqSuQY4JF2aQDRrhML9AfoO2g5oIJXiGtBvQg08QHoozrcQTMHHvPQIPME5inQ5R2sZOGvoJ4DUR5bihvr1wqeCRYCaCFoH+DeoMwBXT1A0UC9g7LOga+JqK2CO5slKj0MfYDqL0FZ9594ggr1vFMMpkAD3+ZicKyvGvW8KS1IIvw1aBHIdNDsYNynOwe6A9Q41leLQuQeoJ8Gy0/QfSzns0uYB20hdYABpoH+AINEnDiHHZT4VDdQsEDTwHyCn8sGShADVBvofoJf8gaq82REifTXoBxABaR2gcoRNweKDUQi+QCjKT+X1CVgMJVs6mAmlVigN9ig85/TJCg2QdZjDBm8R+hgIf3XoO9gGw/ArwPzDg7PZ1TS8a9BeYISqYHlApq/BGUDwwmGNi4PIMj+PaiaU/Yj+7iHQKaBngPS29ZGOMHyo727x40bBqIAPAILlToCj8KbhQJSpMyVCOQAOULYpWWqCAjBl3W22NjgDjUz9E8Qv1bGZ0vzRoS3WQfkmKTg9eSot6v0NwjIwe12FF0S6xNwl4HrU9Df/hOt7pcK9Lfj/FG25g4ApANLH4xysFEA3QNLQNOBvgOuf8AqBLdG8QHMHRCueBw6MNwBNxQ5iAcw9cC1rMhSsC73QHcB5R+m+SsY9x74qdAHEoOOBUkJgrpg1oDrT9DSOuCCzwowHOt37K4PflWB25cLWLvgNxXoL+B6dEGowPARaSvUCZBUoEMO88BYokNBngi2BUCaB/6oC4Cd+VpvIYhKAGgieBDQumAAacBCEXUmmCni6IJeByYKyH2wKUGP1AW3qgJ3WkHdrIcKJKJM/RQFGBox0YDHZNCXyeCWJ4NuN4P0CCT6j0DowDIL3N7BDriLQP8vgxHXpNcFA67JLwhmERhfASwiEPfB8Fzgofp2xPSCYJWAjgH9c4FNcwJgvw9CAm4vAvLX+PgzYFK8G0AMmCeBqwaMZ8CiWOXGgYdi8xpX+ipfFB5sikWpHAhBrzlwgbzZ/hyY5DU8GFBSxMiBBHlvwHYX4t4sPBjFvVlPghC3BpkBBWP2PBjYy4o/IUjHvIAHvXTM7gbuPAjpTLAPrifZ4gE0AItsT4BBTVGFj7Ax4Pk32DYCHSBqYhzd0QLRPTtIQOzn9o7fBDA/wv/6MgTHVfQnwPhIHI54PMMAZeaDiXkssvCd2N4OyBxiqjTqx70ZsDLbJA2/p1qw3APjWwEze4zZN8++ezvR3FUhmrsqjT137KC92XUqyB9ohl73E829tjebP3G9ttdzm000t9mNARddDZnoasgk2mto703iQG9vjb03xGU1t8bem0pszEO29ybzoLe2xj5m4uOMQ7aP+aBBjEO2b3MagZtpk+3L12iUxTQT+66UMegtM7FPhcZxhneXvdrlDBj0j9DeRDqTRd1CexMzo6iKQ+eyKErDJ+ru2H7PdDqqVttfEDudj6KE9qdIogTLGvPVsVXGnt8ubwuXPBpAmwAAAABJRU5ErkJggg==");
        background-position: center;
        background-size: contain;
        background-repeat: no-repeat;
        transform: scale(0.5) translateY(-5%);
        opacity: 0.08;
        box-sizing: border-box;
        animation: 0.25s cauldron-logo-appears ease-in; }

/** Material STUBS **/
.cauldron-themeable {
  /** Size resets */
  --mdc-theme-primary: #3741bc;
  --mdc-typography-subtitle1-font-size: 11pt;
  --mdc-typography-subtitle1-line-height: 1.5em;
  --mdc-typography-subtitle2-font-size: 0.875em;
  --mdc-typography-caption-font-size: 0.75em;
  --mdc-typography-caption-line-height: 1.25em;
  --mdc-typography-body1-font-size: 1em;
  --mdc-typography-body2-font-size: 0.875em;
  --mdc-typography-headline6-font-size: 1.25em;
  --mdc-typography-button-font-size: 0.875em;
  font-size: 10pt;
  /** Mixin fixes for mixins that drop live customizability **/ }
  .cauldron-themeable .mdc-list {
    line-height: var(--mdc-typography-subtitle1-line-height, 1.5em); }
  .cauldron-themeable .mdc-menu .mdc-list, .cauldron-themeable .mdc-dialog .mdc-dialog__content, .cauldron-themeable .mdc-menu .mdc-list-item__graphic, .cauldron-themeable .mdc-data-table__header-cell, .cauldron-themeable .mdc-menu .mdc-list-item__meta,
  .cauldron-themeable .mdc-data-table__pagination-total, .cauldron-themeable .mdc-data-table__pagination-rows-per-page-label, .cauldron-themeable .mdc-data-table__cell,
  .cauldron-themeable .mdc-tab:not(.mdc-tab--active) .mdc-tab__icon, .cauldron-themeable .mdc-tab:not(.mdc-tab--active) .mdc-tab__text-label,
  .cauldron-themeable .mdc-dialog .mdc-dialog__title {
    color: var(--mdc-theme-text-primary-on-background); }
  .cauldron-themeable .mdc-radio .mdc-radio__native-control:enabled:not(:checked) + .mdc-radio__background .mdc-radio__outer-circle {
    border-color: var(--mdc-theme-text-secondary-on-background); }
  .cauldron-themeable .mdc-text-field:not(.mdc-text-field--disabled) + .mdc-text-field-helper-line .mdc-text-field-helper-text {
    color: var(--mdc-theme-secondary); }
  .cauldron-themeable .cauldron-editor-component-toolbar .mdc-list-item__graphic {
    margin-right: 0; }
</style>

                <style id="theme_dark-style">
.cauldron-themeable[cauldron-theme="dark"] {
  --mdc-theme-primary: #3ea2ff;
  --mdc-theme-secondary: #0fa5ff;
  --mdc-theme-background: rgb(24, 24, 24);
  --mdc-theme-surface: rgb(38, 40, 56);
  --mdc-theme-error: #b00020;
  --mdc-theme-on-primary: #fff;
  --mdc-theme-on-secondary: #fff;
  --mdc-theme-on-surface: rgb(230, 234, 255);
  --mdc-theme-on-error: #fff;
  --mdc-theme-text-primary-on-background: rgba(255, 255, 255, 0.973);
  --mdc-theme-text-secondary-on-background: rgba(106, 197, 255, 0.54);
  --mdc-theme-text-hint-on-background: rgba(0, 0, 0, 0.38);
  --mdc-theme-text-disabled-on-background: rgba(0, 0, 0, 0.38);
  --mdc-theme-text-icon-on-background: rgba(218, 234, 255, 0.61);
  --mdc-theme-text-primary-on-light: rgba(0, 0, 0, 0.87);
  --mdc-theme-text-secondary-on-light: rgba(0, 0, 0, 0.54);
  --mdc-theme-text-hint-on-light: rgba(0, 0, 0, 0.38);
  --mdc-theme-text-disabled-on-light: rgba(0, 0, 0, 0.38);
  --mdc-theme-text-icon-on-light: rgba(0, 0, 0, 0.38);
  --mdc-theme-text-primary-on-dark: white;
  --mdc-theme-text-secondary-on-dark: rgba(255, 255, 255, 0.7);
  --mdc-theme-text-hint-on-dark: rgba(255, 255, 255, 0.5);
  --mdc-theme-text-disabled-on-dark: rgba(255, 255, 255, 0.5);
  --mdc-theme-text-icon-on-dark: rgba(255, 255, 255, 0.5);
  /** Menu highlights **/
  /** Golden layout **/ }
  .cauldron-themeable[cauldron-theme="dark"] :not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple::before,
  .cauldron-themeable[cauldron-theme="dark"] :not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple::after {
    background-color: #fff; }
  .cauldron-themeable[cauldron-theme="dark"] .cauldron-layout .lm_items:empty::after,
  .cauldron-themeable[cauldron-theme="dark"] .lm_header .lm_tab .lm_close_tab,
  .cauldron-themeable[cauldron-theme="dark"] .lm_controls {
    filter: invert(1); }
  .cauldron-themeable[cauldron-theme="dark"] .lm_content {
    border-color: #3c4347; }
</style>

            </div>

            <div class="package" id="CauldronSettings">
                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "Cauldron Editor Settings",
    "description": "Settings for cauldron",
    "dependencies": [
        "codestrates-repos #EventSystem"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",    
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <script id="settings-script" type="disabled">
/**
 *  Cauldron Settings
 *  Provides settings that are preserved via localStorage
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 **/

class CauldronSettings {
    /**
     * Sets word-wrap state
     * @param {boolean} state - true/false state of word-wrap
     */
    static setWordwrap(state) {
        CauldronSettings.setSetting(CauldronSettings.SETTINGS.wordWrap, state);
    }

    /**
     *
     * @returns {boolean} true/false depending on if word wrap should be enabled or not
     */
    static getWordwrap() {
        return CauldronSettings.getSetting(CauldronSettings.SETTINGS.wordWrap, false);
    }
    
    
    static setTheme(theme) {
        CauldronSettings.setSetting(CauldronSettings.SETTINGS.theme, theme);
    }    
    
    static getTheme(){
        // Try to detect the browser default theme if not set
        let defaultTheme = "light";
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            defaultTheme = "dark";
        }
        
        return CauldronSettings.getSetting(CauldronSettings.SETTINGS.theme, defaultTheme);        
    }

    /**
     *
     * @param {string} key
     * @param {any} setting
     */
    static setSetting(key, setting) {
        let settings = CauldronSettings.getSettings();
        settings[key] = setting;
        CauldronSettings.setSettings(settings);
    }

    /**
     *
     * @param {string} key
     * @param {any} defaultValue
     */
    static getSetting(key, defaultValue) {
        let settings = CauldronSettings.getSettings();
        if(settings.hasOwnProperty(key)) {
            return settings[key];
        }

        return defaultValue;
    }

    /**
     *
     * @param {Object} settings
     */
    static setSettings(settings) {
        localStorage.setItem(CauldronSettings.STORAGE_KEY, JSON.stringify(settings));

        EventSystem.triggerEvent("Cauldron.Settings.Updated", settings);
        console.log("Settings updated:", settings);
    }

    /**
     *
     * @returns {Object}
     */
    static getSettings() {
        try {
            let settings = JSON.parse(localStorage.getItem(CauldronSettings.STORAGE_KEY));

            if(settings == null || typeof settings !== "object") {
                settings = {};
            }

            return settings;
        } catch(e) {
            //Ignore
            console.warn("Unable to load CauldronSettings, resetting...");
        }

        return {}
    }
}

window.Cauldron.CauldronSettings = CauldronSettings;

CauldronSettings.SETTINGS = {
    "wordWrap": "wordWrap",
    "theme" : "theme"
};

CauldronSettings.STORAGE_KEY = "Cauldron.Settings.Key";

</script>

            </div>

            <div class="package" id="CauldronMainMenu">
                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "Main Menu",
    "description": "Provides the main menu for the editor",
    "dependencies": [
        "webstrate-components-repos #MenuSystem"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",    
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <script id="mainmenu-script" type="disabled">
/**
 *  CauldronMainMenu
 *  The primary top menu of Cauldron
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
    
window.CauldronMainMenu = class MainMenu {
    constructor(){        
        this.menu = MenuSystem.MenuManager.createMenu("Cauldron.MainMenu", {
            keepOpen: true,
            layoutDirection: MenuSystem.Menu.LayoutDirection.HORIZONTAL
        });
        
        // Register the basic submenus etc. that are always there
        let fileMenu = MenuSystem.MenuManager.createMenu("Cauldron.File", {
            groupDividers: true,
            growDirection: MenuSystem.Menu.GrowDirection.DOWN
        });
        this.menu.addItem({            
            label: "File",
            order: 0,
            submenu: fileMenu,
            submenuOnHover: false
        });

        // Register the basic submenus etc. that are always there
        let settingsMenu = MenuSystem.MenuManager.createMenu("Cauldron.Settings", {
            groupDividers: true,
            growDirection: MenuSystem.Menu.GrowDirection.DOWN
        });
        this.menu.addItem({
            label: "Settings",
            order: 100,
            submenu: settingsMenu,
            submenuOnHover: false
        });

        let viewMenu = MenuSystem.MenuManager.createMenu("Cauldron.View", {
            groupDividers: true,
            growDirection: MenuSystem.Menu.GrowDirection.DOWN
        });
        this.menu.addItem({
            label: "View",
            order: 200,
            submenu: viewMenu,
            submenuOnHover: false
        });
        
        let helpMenu = MenuSystem.MenuManager.createMenu("Cauldron.Help", {
            growDirection: MenuSystem.Menu.GrowDirection.DOWN
        });
        this.menu.addItem({
            label: "Help",
            order: 999,
            submenu: helpMenu,
            submenuOnHover: false
        });

        
        this.menu.open();
        this.menu.html.classList.add("cauldron-mainmenu");
    }
    
    get html(){
        return this.menu.html;
    }
}

</script>

                <style id="mainmenu-style">
.cauldron-mainmenu {
    flex: 1 1 auto;
}
</style>

            </div>    
            <div class="package" id="CauldronActionMenu">
                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "Main Actionbar",
    "description": "Provides a small area for prominent actions",
    "dependencies": [
        "webstrate-components-repos #MenuSystem"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <script id="actionmenu-script" type="disabled">
/**
 *  CauldronActionMenu
 *  A menu for prominent Cauldron actions like closing Cauldron
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

window.CauldronActionMenu = class MainActions {
    constructor(){        
        this.menu = MenuSystem.MenuManager.createMenu("Cauldron.MainActions", {
            keepOpen: true,
            layoutDirection: MenuSystem.Menu.LayoutDirection.HORIZONTAL            
        });
        
        this.menu.open();
        this.menu.html.classList.add("cauldron-actionmenu");
    }
    
    get html(){
        return this.menu.html;
    }
}

</script>

                <style id="actionmenu-style">
/**
 *  CauldronActionMenu Styles
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
.cauldron-actionmenu {
  opacity: 0.7;
  /* Material Design STUB */ }
  .cauldron-actionmenu:hover {
    opacity: 1; }
  .cauldron-actionmenu .mdc-list-item {
    padding: 0; }
    .cauldron-actionmenu .mdc-list-item .mdc-list-item__graphic {
      margin: 0; }
</style>

            </div>    
            <div class="package" id="NewWebstrateActions">
                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "New Webstrate",
    "description": "Actions that can create new Webstrates",
    "dependencies": [
        "webstrate-components-repos #MenuSystem"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",    
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <script id="new-webstrate-actions-script" type="disabled">
/**
 *  Webstrate Actions
 *  Ways of copying and manipulating a webstrate into a new one through the menu
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

if (typeof webstrate !== "undefined"){
    let newMenu = MenuSystem.MenuManager.createMenu("Cauldron.File.NewWebstrate");

    MenuSystem.MenuManager.registerMenuItem("Cauldron.File", {
        label: "New...",
        group: "FileDirect",
        groupOrder: -1,
        order: -1,
        icon: IconRegistry.createIcon("mdc:note_add"),
        submenu: newMenu
    });

    // New empty webstrate
    MenuSystem.MenuManager.registerMenuItem("Cauldron.File.NewWebstrate", {
        label: "Empty",
        icon: IconRegistry.createIcon("mdc:description"),        
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Webstrate.New", {
                type: "empty"
            });
        }
    });

    // Download as archive
    MenuSystem.MenuManager.registerMenuItem("Cauldron.File", {
        label: "Download",
        group: "FileDirect",
        icon: IconRegistry.createIcon("mdc:archive"),                
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Webstrate.Download");
        }
    });

    // New copy from this one
    MenuSystem.MenuManager.registerMenuItem("Cauldron.File.NewWebstrate", {        
        label: "Copy",
        icon: IconRegistry.createIcon("mdc:file_copy"),        
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Webstrate.New", {
                type: "copy"
            });
        }
    });

    // New from prototype url
    MenuSystem.MenuManager.registerMenuItem("Cauldron.File.NewWebstrate", {
        label: "From URL...",
        icon: IconRegistry.createIcon("mdc:link"),        
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Webstrate.New", {
                type: "url"
            });
        }
    });

    // New from prototype file
    MenuSystem.MenuManager.registerMenuItem("Cauldron.File.NewWebstrate", {
        label: "From File...",
        icon: IconRegistry.createIcon("mdc:unarchive"),        
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Webstrate.New", {
                type: "file"
            });
        }
    });

    EventSystem.registerEventCallback("Cauldron.Webstrate.Download", ()=>{
        let iframe = document.createElement("iframe");
        let transient = document.createElement("transient");
        transient.style.display = "none";

        transient.appendChild(iframe);

        iframe.webstrate.on("transcluded", async (webstrate)=>{
            console.log("Webstrate created:", webstrate);

            //Insert WPMv2
            await WPMv2.installWPMInto("/"+webstrate);

            transient.remove();
        });

        iframe.src = location.href + "?dl";

        document.body.appendChild(transient);
    });

    EventSystem.registerEventCallback("Cauldron.Webstrate.New", ({detail: {type: type}})=>{
        let iframe = document.createElement("iframe");
        let transient = document.createElement("transient");
        transient.style.display = "none";

        transient.appendChild(iframe);

        iframe.webstrate.on("transcluded", async (webstrate)=>{
            console.log("Webstrate created:", webstrate);

            //Insert WPMv2
            await WPMv2.installWPMInto("/"+webstrate);

            transient.remove();

            window.open("/"+webstrate);
        });

        switch(type) {
            case "empty":
                iframe.src = "/new";
                break;
            case "copy":
                iframe.src = location.href + "?copy";
                break;
            case "file": {
                let fileInput = document.createElement("input");
                fileInput.setAttribute("type", "file");
                fileInput.setAttribute("name", "file");
                fileInput.setAttribute("accept", ".zip");
                fileInput.click();

                fileInput.addEventListener("input", ()=>{
                    let formElement = document.createElement("form");
                    formElement.appendChild(fileInput);

                    let formData = new FormData(formElement);

                    fetch("/new", {
                        method: "POST",
                        body: formData
                    }).then((response)=>{
                        iframe.src = response.url;
                    });
                });
                break;
            }
            case "url": {
                let url = prompt("Prototype URL:");

                if(url.trim().length > 0) {
                    iframe.src = "/new?prototypeUrl="+url;
                }

                break;
            }
            default:
                console.log("Unknown type:", type);
        }

        document.body.appendChild(transient);
    });
}

</script>

            </div>
            <div class="package" id="DocumentActions">
                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "Document Actions",
    "description": "Actions that change document",
    "dependencies": [
        "webstrate-components-repos #MenuSystem"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",    
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <script id="document-actions-script" type="disabled">
/**
 *  Document Actions
 *
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 **/

MenuSystem.MenuManager.registerMenuItem("Cauldron.File", {
    label: "Title",
    group: "DocumentActions",
    groupOrder: 1,
    order: 0,
    icon: IconRegistry.createIcon("mdc:title"),
    onAction: (menuItem)=>{
        EventSystem.triggerEvent("Document.Edit.Title");
    }
});

EventSystem.registerEventCallback("Document.Edit.Title", ()=>{
    let content = WebstrateComponents.Tools.loadTemplate("#document-title-edit-dialog-tpl");

    content.querySelector("input.title").value = document.title;

    let dialog = new WebstrateComponents.ModalDialog(content);

    content.querySelector("button.save").addEventListener("pointerup", ()=>{
        dialog.close("save");
    });

    content.querySelector("button.cancel").addEventListener("pointerup", ()=>{
        dialog.close("cancel");
    });

    EventSystem.registerEventCallback("ModalDialog.Closed", ({detail: {dialog: closingDialog, action}})=>{
        if(closingDialog === dialog) {
            if(action === "save") {
                document.title = content.querySelector("input.title").value;
            }
        }
    });

    document.querySelector("html").appendChild(dialog.html);

    dialog.open();
});


</script>

                <template id="document-title-edit-dialog-tpl">
    <div>
        <label>Title: <input type="text" class="title"></label>
        <br>
        <button class="save">Save</button><button class="cancel">Cancel</button>
    </div>
</template>

            </div>
            <div class="package" id="CauldronEditorViewActions">
                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "Editor View Actions",
    "description": "Actions that change Cauldron",
    "dependencies": [
        "webstrate-components-repos #MenuSystem",
        "#CauldronSettings"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",    
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <script id="cauldron-editor-view-actions-script" type="disabled">
/**
 *  View Actions
 *  Control the Cauldron docking mode
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

{
    MenuSystem.MenuManager.registerMenuItem("Cauldron.File", {
        label: "Close",
        group: "Cauldron",
        icon: IconRegistry.createIcon("mdc:close"),                        
        order: 9000,
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Minimize");
        }
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.Settings", {
        label: "Word-wrap",
        icon: IconRegistry.createIcon("mdc:wrap_text"),
        order: 0,
        checked: ()=>Cauldron.CauldronSettings.getWordwrap(),
        onAction: (menuItem)=>{
            //Toggle word wrap in all open and future editors
            Cauldron.CauldronSettings.setWordwrap(!Cauldron.CauldronSettings.getWordwrap());
        }
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.MainActions", {
        icon: IconRegistry.createIcon("mdc:close"),
        order: 9000,
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Minimize");
        }
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.View.Dock",{
        label: "Left",
        icon: IconRegistry.createIcon("mdc:vertical_split"),
        order: 0,
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Dock", {
                pos: EdgeDocker.MODE.LEFT
            });
        }
    });
    MenuSystem.MenuManager.registerMenuItem("Cauldron.View.Dock",{
        label: "Right",
        icon: IconRegistry.createIcon("mdc:vertical_split"),
        order: 0,
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Dock", {
                pos: EdgeDocker.MODE.RIGHT
            });
        }
    });
    MenuSystem.MenuManager.registerMenuItem("Cauldron.View.Dock",{
        label: "Bottom",
        icon: IconRegistry.createIcon("mdc:horizontal_split"),
        order: 0,
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Dock", {
                pos: EdgeDocker.MODE.BOTTOM
            });
        }
    });
    MenuSystem.MenuManager.registerMenuItem("Cauldron.View.Dock",{
        label: "Float",
        icon: IconRegistry.createIcon("mdc:featured_video"),        
        order: 0,
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Dock", {
                pos: EdgeDocker.MODE.FLOAT
            });
        }
    });
    MenuSystem.MenuManager.registerMenuItem("Cauldron.View.Dock",{
        label: "Maximize",
        icon: IconRegistry.createIcon("mdc:aspect_ratio"),        
        order: 0,
        onAction: ()=>{
            EventSystem.triggerEvent("Cauldron.Dock", {
                pos: EdgeDocker.MODE.MAXIMIZED
            });
        }
    });

    let dockMenu = MenuSystem.MenuManager.createMenu("Cauldron.View.Dock");
    MenuSystem.MenuManager.registerMenuItem("Cauldron.View", {
        label: "Dock...",
        group: "Positioning",
        groupOrder:0,
        icon: IconRegistry.createIcon("mdc:view_quilt"),                        
        order: 0,
        submenu: dockMenu
    });
    
    let themeMenu = MenuSystem.MenuManager.createMenu("Cauldron.View.Theme");
    MenuSystem.MenuManager.registerMenuItem("Cauldron.View", {
        label: "Theme...",
        group: "LayoutCommands",
        groupOrder:0,
        icon: IconRegistry.createIcon("mdc:brush"),                        
        order: 0,
        submenu: themeMenu
    });
    
    ["Light", "Dark"].forEach((theme)=>{
        MenuSystem.MenuManager.registerMenuItem("Cauldron.View.Theme",{
            label: theme,
            order: 0,
            checked: ()=>Cauldron.CauldronSettings.getTheme()===theme.toLowerCase(),
            onAction: ()=>{
                Cauldron.CauldronSettings.setTheme(theme.toLowerCase());
                EventSystem.triggerEvent("Cauldron.Theme", {
                    theme: theme.toLowerCase()
                });
            }
        });       
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.View", {
        label: "Reset layout",
        group: "LayoutCommands",
        groupOrder:10,
        
        
        icon: IconRegistry.createIcon("mdc:settings_backup_restore"),
        order: 1,
        onAction:()=>{
            EventSystem.triggerEvent("Cauldron.ResetLayout");
        }
    });
}

</script>

            </div>
            <div class="package" id="CauldronEditorTabActions">
                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "Editor Tabs Actions",
    "description": "Actions that affect editor tabs",
    "dependencies": [
        "webstrate-components-repos #MenuSystem"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",    
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <script id="cauldron-editor-tabs-actions-script" type="disabled">
/**
 *  Tab Actions
 *  Control the Cauldron tabs
 * 
 *  Copyright 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

{
    MenuSystem.MenuManager.registerMenuItem("Cauldron.Tab.ContextMenu", {
        label: "Close",
        group: "Tab",
        icon: IconRegistry.createIcon("mdc:close"),                        
        order: 100,
        onAction: (e)=>{
            e.menu.context.tab.closeElement.click();
        }
    });
    
    MenuSystem.MenuManager.registerMenuItem("Cauldron.Tab.ContextMenu", {
        label: "Close Other",
        group: "Tab",
        icon: IconRegistry.createIcon("mdc:close"),                        
        order: 110,
        onOpen: (e)=>e.context.tab.header.tabs.length>1,
        onAction: (e)=>{
            let ourContent = e.menu.context.tab.contentItem;
            
            for (let tab of e.menu.context.tab.header.tabs.slice()){
                if (tab.contentItem != ourContent){
                    tab.closeElement.click();
                }
            };
            return true;            
        }
    });
    
    MenuSystem.MenuManager.registerMenuItem("Cauldron.Tab.ContextMenu", {
        label: "Close All",
        group: "Tab",
        icon: IconRegistry.createIcon("mdc:close"),                        
        order: 120,
        onOpen: (e)=>e.context.tab.header.tabs.length>1,
        onAction: (e)=>{
            for (let tab of e.menu.context.tab.header.tabs.slice()){
                tab.closeElement.click();
            };
            return true;            
        }
    });    
    
}

</script>

            </div>            
            <div class="package" id="CauldronEditorCodestratesActions">
                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "Codestrates Actions",
    "description": "Several actions that apply to code fragments",
    "dependencies": [
        "webstrate-components-repos #MenuSystem",
        "webstrate-components-repos #wsc-icon-registry"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <script id="fragment-actions-script" type="disabled">
/**
 *  Fragment Actions
 *  Menu entries related to fragments in codestrates
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

MenuSystem.MenuManager.registerMenuItem("Cauldron.Editor.Toolbar", {
    label: "Run",
    icon: IconRegistry.createIcon(["mdc:play_arrow"]),
    tooltip: "Execute the contents of this fragment",
    order: 200,
    class: "runAction",
    onAction: (menuItem)=>{
        EventSystem.triggerEvent("Codestrates.Fragment.Run", {
            fragment: menuItem.menu.context
        });
    },
    onOpen: (menu, menuItem)=>{
        return menu.context.supportsRun();
    }
});
EventSystem.registerEventCallback("Codestrates.Fragment.Run", async ({detail: {fragment: fragment}})=>{
    try {
        let result = await fragment.require();
        console.log("Require result: ", result);
    } catch(e) {
    }
});

MenuSystem.MenuManager.registerMenuItem("Cauldron.Editor.Toolbar", {
    label: "Auto",
    icon: IconRegistry.createIcon(["mdc:play_circle_outline"]),
    tooltip: "Run this fragment automatically",
    order: 100,
    class: "autoAction",
    onAction: (menuItem)=>{
        EventSystem.triggerEvent("Codestrates.Fragment.Auto", {
            fragment: menuItem.menu.context
        });

        menuItem.active = menuItem.menu.context.auto;
    },
    onOpen: (menu, menuItem)=>{
        if(menu.context.supportsAuto()) {
            menuItem.active = menu.context.auto;
            return true;
        }

        return false;
    }
});

// Single-element Autorun On/Off
MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Enable Autorun",
    icon: IconRegistry.createIcon("mdc:play_circle_outline"),
    tooltip: "Execute the contents of this fragment when the page loads",    
    group: "EditActions",
    groupOrder: 200,
    order: 200,
    onOpen: (menu)=>{
        if(menu.context.type == "DomTreeNode" && menu.context.context.matches("code-fragment")) {
            let fragment = Fragment.one(menu.context.context);

            return fragment.supportsAuto() && !fragment.auto;
        }
    },
    onAction: (menuItem)=>{
        EventSystem.triggerEvent("Codestrates.Fragment.AutoOn", {
            fragment: Fragment.one(menuItem.menu.context.context)
        });
    }
});
MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Disable Autorun",
    icon: IconRegistry.createIcon("mdc:play_circle_outline"),
    tooltip: "Stop executing the contents of this fragment when the page loads",        
    group: "EditActions",
    groupOrder: 200,
    order: 200,
    onOpen: (menu)=>{
        if(menu.context.type == "DomTreeNode" && menu.context.context.matches("code-fragment")) {
            let fragment = Fragment.one(menu.context.context);

            return fragment.supportsAuto() && fragment.auto;
        }
    },
    onAction: (menuItem)=>{
        EventSystem.triggerEvent("Codestrates.Fragment.AutoOff", {
            fragment: Fragment.one(menuItem.menu.context.context)
        });
    }
});

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Enable Autorun Recursively",
    icon: IconRegistry.createIcon("mdc:play_circle_outline"),
    group: "FragmentActions",
    groupOrder: 9000,
    order: 205,
    onOpen: (menu)=>{
        if(menu.context.type == "DomTreeNode") {
            let childFragments = Fragment.find(menu.context.context.querySelectorAll("code-fragment"));

            let autoFragment = childFragments.find((fragment)=>{
                return fragment.supportsAuto() && !fragment.auto;
            });

            return autoFragment != null;
        }
    },
    onAction: (menuItem)=>{
        let fragments = menuItem.menu.context.context.querySelectorAll("code-fragment");
        fragments.forEach((fragmentHtml)=>{
            let fragment = Fragment.one(fragmentHtml);
            if(fragment.supportsAuto() && !fragment.auto) {
                EventSystem.triggerEvent("Codestrates.Fragment.AutoOn", {
                    fragment: fragment
                });
            }
        });
    }
});
MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Disable Autorun Recursively",
    icon: IconRegistry.createIcon("mdc:play_circle_outline"),
    group: "FragmentActions",
    groupOrder: 9000,
    order: 210,
    onOpen: (menu)=>{
        if(menu.context.type == "DomTreeNode") {
            let childFragments = Fragment.find(menu.context.context.querySelectorAll("code-fragment"));

            let autoFragment = childFragments.find((fragment)=>{
                return fragment.supportsAuto() && fragment.auto;
            });

            return autoFragment != null;
        }
    },
    onAction: (menuItem)=>{
        let fragments = menuItem.menu.context.context.querySelectorAll("code-fragment");
        fragments.forEach((fragmentHtml)=>{
            let fragment = Fragment.one(fragmentHtml);
            if(fragment.supportsAuto() && fragment.auto) {
                EventSystem.triggerEvent("Codestrates.Fragment.AutoOff", {
                    fragment: fragment
                });
            }
        });
    }
});
EventSystem.registerEventCallback("Codestrates.Fragment.Auto", ({detail: {fragment: fragment}})=>{
    fragment.auto = !fragment.auto;
});
EventSystem.registerEventCallback("Codestrates.Fragment.AutoOn", ({detail: {fragment: fragment}})=>{
    fragment.auto = true;
});
EventSystem.registerEventCallback("Codestrates.Fragment.AutoOff", ({detail: {fragment: fragment}})=>{
    fragment.auto = false;
});


EventSystem.registerEventCallback("TreeBrowser.Keyup", ({detail: {evt: evt, treeNode: treeNode}})=>{
    if(evt.key === "Delete") {
        if(treeNode.type === "DomTreeNode") {
            EventSystem.triggerEvent("Codestrates.DomNode.Delete", {
                treeNode: treeNode
            });
        }
    }
});

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Delete",
    icon: IconRegistry.createIcon("mdc:delete"),                            
    group: "ViolentActions",
    groupOrder: 9000,
    order: 200,
    onOpen: (menu)=>{
        if(menu.context.type == "DomTreeNode") {
            return true;
        }
    },
    onAction: (menuItem)=>{
        EventSystem.triggerEvent("Codestrates.DomNode.Delete", {
            treeNode: menuItem.menu.context
        });
    }
});
MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Move Up",
    icon: IconRegistry.createIcon("mdc:north"),
    group: "EditActions",
    groupOrder: 9000,
    order: 1000,
    onOpen: (menu)=>{
        if(menu.context.type === "DomTreeNode"){
            let children = Array.from(menu.context.context.parentNode.children);
            return children.indexOf(menu.context.context)>0;
        }
    },
    onAction: (menuItem)=>{
        let children = Array.from(menuItem.menu.context.context.parentNode.children);
        let currentIndex = children.indexOf(menuItem.menu.context.context);
        menuItem.menu.context.context.parentNode.insertBefore(menuItem.menu.context.context, children[currentIndex-1]);
    }
});
MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Move Down",
    icon: IconRegistry.createIcon("mdc:south"),
    group: "EditActions",
    groupOrder: 9000,
    order: 1001,
    onOpen: (menu)=>{
        if(menu.context.type === "DomTreeNode"){
            let children = Array.from(menu.context.context.parentNode.children);
            return children.indexOf(menu.context.context)<children.length-1;
        }
    },
    onAction: (menuItem)=>{        
        let children = Array.from(menuItem.menu.context.context.parentNode.children);
        let currentIndex = children.indexOf(menuItem.menu.context.context);
        menuItem.menu.context.context.parentNode.insertBefore(menuItem.menu.context.context, currentIndex===children.length-2?null:children[currentIndex+2]);
    }
});

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Duplicate",
    icon: IconRegistry.createIcon("mdc:content_copy"),
    group: "EditActions",
    groupOrder: 9000,
    order: 900,
    onOpen: (menu)=>menu.context.type === "DomTreeNode",
    onAction: (menuItem)=>{
        let clone = menuItem.menu.context.context.cloneNode(true);
        WPMv2.stripProtection(clone);
        menuItem.menu.context.context.parentNode.insertBefore(clone, menuItem.menu.context.context);
    }
});

EventSystem.registerEventCallback("Codestrates.DomNode.Delete", ({detail: {treeNode: treeNode}})=>{
    let decision = confirm("Really delete: "+treeNode.getProperty("content"));
    if(decision) {
        treeNode.context.parentNode.removeChild(treeNode.context);
    }
});

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Insert WPM Package",
    icon: IconRegistry.createIcon("webstrates:wpm-package-open"),
    order: 20,
    group: "inserters",
    groupOrder: -1,
    onOpen: (menu)=>{
        if (!window.DescriptorFragment) return false;
        return menu.context.type == "DomTreeNode" && !menu.context.context.matches("code-fragment, wpm-package");
    },
    onAction: (menuItem)=>{
        EventSystem.triggerEvent("Codestrates.Fragment.CreateWPMPackage", {
            treeNode: menuItem.menu.context
        });
    }
});

EventSystem.registerEventCallback("Codestrates.Fragment.CreateWPMPackage", ({detail: {treeNode: treeNode}})=>{
    let wpmPackage = document.createElement("wpm-package");

    let wpmDescriptor = Fragment.create("wpm/descriptor");
    wpmPackage.appendChild(wpmDescriptor.html[0]);

    WPMv2.stripProtection(wpmPackage);

    treeNode.context.appendChild(wpmPackage);
    setTimeout(()=>{
        let treeBrowser = treeNode.getTreeBrowser();
        let treeNodes = treeBrowser.findTreeNodeForContext(wpmPackage);
        if(treeNodes.length > 0) {
            let treeNode = treeNodes[0];
            treeNode.reveal();
            treeNode.select();
        }
    }, 0);
});

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Insert DOM Element",
    order: 10,
    icon: IconRegistry.createIcon("mdc:code"),                                
    group: "inserters",
    groupOrder: -1,
    onOpen: (menu)=>{
        return menu.context.type == "DomTreeNode" && !menu.context.context.matches("code-fragment, wpm-package");
    },
    onAction: (menuItem)=>{
        let elementType = prompt("Which element?");
        if (elementType===null) return;
        
        try {
            let element = document.createElement(elementType, {approved: true});
            menuItem.menu.context.context.appendChild(element);
            setTimeout(()=>{
                let treeBrowser = menuItem.menu.context.getTreeBrowser();
                let treeNodes = treeBrowser.findTreeNodeForContext(element);
                if(treeNodes.length > 0) {
                    let treeNode = treeNodes[0];
                    treeNode.reveal();
                    treeNode.select();
                }
            }, 0);
        } catch(e) {
            console.error(e);
        }
    }
});

let fragmentMenu = MenuSystem.MenuManager.createMenu("FragmentInsertMenu");

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Insert Fragment",
    icon: IconRegistry.createIcon("mdc:note_add"),                            
    order: 0,
    group: "inserters",
    groupOrder: -1,
    onOpen: (menu)=>{
        if (Fragment.fragmentTypes.size === 0) return false;
        
        let canOpen = menu.context.type == "DomTreeNode" && !menu.context.context.matches("code-fragment");
        
        // Check for new fragments not already registered in the menu
        if (!fragmentMenu.alreadyRegistered){
            fragmentMenu.alreadyRegistered = [];
        }
        Fragment.fragmentTypes.forEach((fragment, fragType)=>{    
            if (!fragmentMenu.alreadyRegistered.includes(fragType)){
                MenuSystem.MenuManager.registerMenuItem("FragmentInsertMenu", {
                    label: fragment.name.replace("Fragment",""),                    
                    icon: IconRegistry.createIcon(["code-fragment:"+fragType, "mdc:insert_drive_file"]),
                    onAction: (menuItem)=>{
                        let fragment = Fragment.create(fragType);
                        WPMv2.stripProtection(fragment.html);
                        menuItem.menu.superMenu.context.context.appendChild(fragment.html[0]);
                        setTimeout(()=>{
                            //Find the newly added treenode and open the editor
                            let treeBrowser = menuItem.menu.superMenu.context.getTreeBrowser();
                            let treeNodes = treeBrowser.findTreeNodeForContext(fragment.html[0]);
                            if(treeNodes.length > 0) {
                                let treeNode = treeNodes[0];
                                treeNode.reveal();
                                treeNode.select();
                                //Is this needed?
                                treeNode.triggerAction();
                            }
                        }, 0);
                    }
                });
                fragmentMenu.alreadyRegistered.push(fragType);
            }
        });
        
        return canOpen;
    },
    submenu: fragmentMenu
});


MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Open Preview",
    group: "EditActions",
    groupOrder: 0,
    icon: IconRegistry.createIcon("mdc:web"),                                
    onOpen: (menu)=>{
        if(menu.context.type == "DomTreeNode" && menu.context.context.matches("code-fragment")) {
            let fragment = cQuery(menu.context.context).data("Fragment");

            if(PreviewEditor.types().includes(fragment.type)) {
                return true;
            }
        }
        return false;
    },
    onAction: (menuItem)=>{
        let fragment = cQuery(menuItem.menu.context.context).data("Fragment");

        EventSystem.triggerEvent("Cauldron.Open.Preview", {
            fragment: fragment
        });
    }
});

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Edit InnerHTML",
    icon: IconRegistry.createIcon("mdc:edit"),                                
    group: "EditActions",
    groupOrder: 200,
    order: 100,
    onOpen: (menu)=>{
        return menu.context.type === "DomTreeNode" && !menu.context.context.matches("code-fragment");
    },
    onAction: (menuItem)=>{
        let element = menuItem.menu.context.context;

        //Check for any code-fragment inside element
        if(element.querySelector("code-fragment") != null) {
            let decision = confirm("You are about to edit InnerHTML that contains or is itself a code-fragment, are you sure?");

            if(!decision) {
                return;
            }
        }

        EventSystem.triggerEvent("Cauldron.Open.InnerHTMLEditor", {
            element: menuItem.menu.context.context
        });
    }
});

MenuSystem.MenuManager.registerMenuItem("Cauldron.Editor.Toolbar", {
    label: "Save",
    icon: IconRegistry.createIcon(["mdc:save"]),
    onOpen: (menu)=>{
        return menu.context.isInnerHtmlEditor === true;
    },
    onAction: (menuItem)=>{
        menuItem.menu.context.save();
    }
});

</script>

                <script id="asset-actions-script" type="disabled">
/**
 *  Asset Actions
 *  Menu entries related to assets in wpm packages
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Download",
    group: "TransferActions",
    groupOrder: 0,
    icon: IconRegistry.createIcon("mdc:cloud_download"),                                
    onOpen: (menu)=>{
        return menu.context.type == "AssetNode" || menu.context.type == "AssetContainer";
    },
    onAction: (menuItem) =>{
        EventSystem.triggerEvent("Cauldron.Asset.Download", {
            asset: menuItem.menu.context.context
        });
    }
});

EventSystem.registerEventCallback("Cauldron.Asset.Download", ({detail: {asset: asset}})=>{
    let a = document.createElement("a");
    a.setAttribute("href", location.href+asset.fileName);
    a.setAttribute("download", asset.fileName);
    a.setAttribute("target", "_blank");
    a.click();
});

MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.ContextMenu", {
    label: "Delete",
    icon: IconRegistry.createIcon("mdc:delete"),                                
    group: "ViolentActions",
    groupOrder: 9000,
    onOpen: (menu)=>{
        return (menu.context.type == "AssetNode" || menu.context.type == "AssetContainer");
    },
    onAction: (menuItem)=>{
        if(
            menuItem.menu.context.parentNode != null &&
            menuItem.menu.context.parentNode.parentNode != null &&
            menuItem.menu.context.parentNode.parentNode.type === "DomTreeNode" &&
            menuItem.menu.context.parentNode.parentNode.context.matches("wpm-package")
        ) {
            //Asset inside wpm-package

            let descFrag = cQuery(menuItem.menu.context.parentNode.parentNode.context.querySelector("code-fragment[data-type='wpm/descriptor']")).data("Fragment");
            if(descFrag != null) {
                let decision = confirm("Really delete: "+menuItem.menu.context.getProperty("content"));
                if(decision) {
                    descFrag.require().then((descJson)=>{
                        descJson.assets.splice(descJson.assets.indexOf(menuItem.menu.context.context.fileName), 1);
                        descFrag.raw = JSON.stringify(descJson, null, 2);
                    });
                }
            }
        } else {
            //Asset node not inside a package
            EventSystem.triggerEvent("Codestrates.Asset.Delete", {
                asset: menuItem.menu.context.context,
                success: ()=>{
                    menuItem.menu.context.parentNode.removeNode(menuItem.menu.context);
                },
                fail: (err)=>{
                    console.error(err);
                }
            });
        }
    }
});

EventSystem.registerEventCallback("TreeBrowser.Keyup", ({detail: {evt: evt, treeNode: treeNode}})=>{
    if(evt.key === "Delete") {
        if(treeNode.type === "AssetNode" || treeNode.type === "AssetContainer") {
            EventSystem.triggerEvent("Codestrates.Asset.Delete", {
                asset: treeNode.context,
                success: (err)=>{
                    if(err == null) {
                        treeNode.parentNode.removeNode(treeNode);
                    } else {
                        console.error(err);
                    }
                }
            });
        }
    }
});

EventSystem.registerEventCallback("Codestrates.Asset.Delete", async ({detail: {asset: asset, success: successCallback, fail: failCallback}})=>{
    //Check if asset is used by any wpm-packages.
    let descFragUsingAsset = [];

    for(let wpmPackageElm of Array.from(document.querySelectorAll("wpm-package"))) {
        let descFrag = cQuery(wpmPackageElm).find("code-fragment[data-type='wpm/descriptor']").data("Fragment");

        if(descFrag != null) {
            let descJson = await descFrag.require();

            if(descJson.assets.includes(asset.fileName)) {
                descFragUsingAsset.push(descFrag);
            }
        }
    }

    let msg = "Really delete asset: "+asset.fileName;

    if(descFragUsingAsset.length > 0) {
        msg = "Really delete asset: "+asset.fileName+" (It is currently being used by "+descFragUsingAsset.length+" descriptor fragments, and will be removed from those as well";
    }

    let decision = confirm(msg);
    if(decision) {
        webstrate.deleteAsset(asset.fileName, (err) => {
            if(err == null) {
                for(let descFrag of descFragUsingAsset) {
                    descFrag.require().then((descJson)=>{
                        descJson.assets.splice(descJson.assets.indexOf(asset.fileName), 1);
                        descFrag.raw = JSON.stringify(descJson, null, 2);
                    });
                }
                successCallback();
            } else {
                failCallback(err);
            }
        });
    }
});

</script>

            </div>
            <div class="package" id="CauldronEditorDocumentation">
                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "Documentation Help Menu",
    "description": "Documentation for the help menu",
    "dependencies": [
        "webstrate-components-repos #MenuSystem"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",    
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <script id="documentation-script" type="disabled">
/**
 *  Help Actions
 *  Links to various API and help documentation
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

{
    let documentationMenu = MenuSystem.MenuManager.createMenu("Cauldron.Help.Documentation");

    MenuSystem.MenuManager.registerMenuItem("Cauldron.Help", {
        label: "Documentation",
        icon: IconRegistry.createIcon("mdc:menu_book"),
        submenu: documentationMenu
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.Help.Documentation", {
        label: "Webstrates",
        icon: IconRegistry.createIcon("webstrates:logo"),
        onAction: () => {
            window.open("https://webstrates.github.io/userguide/api.html");
        }
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.Help.Documentation", {
        label: "Codestrates",
        icon: IconRegistry.createIcon("webstrates:codestrates"),
        onAction: () => {
            window.open("https://codestrates.projects.cavi.au.dk/api/codestrates/");
        }
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.Help.Documentation", {
        label: "Cauldron",
        icon: IconRegistry.createIcon("webstrates:cauldron"),
        onAction: () => {
            window.open("https://codestrates.projects.cavi.au.dk/api/cauldron/");
        }
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.Help.Documentation", {
        label: "Webstrate Components",
        icon: IconRegistry.createIcon("webstrates:components"),
        onAction: () => {
            window.open("https://webstrate.projects.cavi.au.dk/docs/webstrate_components/");
        }
    });

    MenuSystem.MenuManager.registerMenuItem("Cauldron.Help.Documentation", {
        label: "Webstrate Package Manager",
        icon: IconRegistry.createIcon("webstrates:wpm-package-open"),
        onAction: () => {
            window.open("https://webstrate.projects.cavi.au.dk/docs/wpmv2/");
        }
    });
}

</script>

            </div>

            <div class="package" id="CauldronConsole">
                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "Console",
    "description": "Show a log of fragment output with easy filtering and search",
    "dependencies": [
        "#CauldronNamespace"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",    
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <script id="console-script" type="disabled">
/**
 *  Cauldron Console
 *  A textual console for error logging
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

window.Cauldron.CauldronConsole = class CauldronConsole {
    constructor() {
        let self = this;

        this.html = document.createElement("div");
        this.html.classList.add("cauldron-console-content");

        this.consoleUl = document.createElement("ul");

        this.html.appendChild(this.consoleUl);

        this.contextMenu = MenuSystem.MenuManager.createMenu("Cauldron.Inspector.ContextMenu");

        //Make errors able to be JSON.stringifyied
        if (!('toJSON' in Error.prototype)) {
            Object.defineProperty(Error.prototype, 'toJSON', {
                value: function () {
                    let alt = {};

                    Object.getOwnPropertyNames(this).forEach(function (key) {
                        alt[key] = this[key];
                    }, this);

                    return alt;
                },
                configurable: true,
                writable: true
            });
        }

        MenuSystem.MenuManager.registerMenuItem("Cauldron.Inspector.ContextMenu", {
            label: "Clear console",
            onAction:()=>{
                self.consoleUl.innerHTML = "";
            }
        });

        MenuSystem.MenuManager.registerMenuItem("Cauldron.Inspector.ContextMenu", {
            label: "Filter",
            onAction:()=>{
                let filter = prompt("Enter filter string:");

                let entries = Array.from(self.consoleUl.querySelectorAll(".cauldron-console-entry"));

                entries.forEach((entry)=>{
                    entry.classList.add("cauldron-console-entry-filtered");
                });

                entries.filter((entry)=>{
                    if(filter == null || filter.trim() === "") {
                        return true;
                    } else {
                        return entry.textContent.toLowerCase().indexOf(filter.trim().toLowerCase()) !== -1;
                    }
                }).forEach((entry)=>{
                    entry.classList.remove("cauldron-console-entry-filtered");
                });
            }
        });

        this.html.addEventListener("contextmenu", (evt)=>{
            evt.preventDefault();
        });

        this.html.addEventListener("mouseup", (evt)=>{
            if(evt.button !== 2) {
                return;
            }

            try {
                //Find top component after html
                let parent = self.html;
                while(parent.parentNode != null && !parent.parentNode.matches("html")) {
                    parent = parent.parentNode;
                }
                parent.appendChild(self.contextMenu.html);

                self.contextMenu.open({
                    x: evt.pageX,
                    y: evt.pageY
                });
            } catch(e) {
                console.error(e);
            }
            evt.preventDefault();
        });

        EventSystem.registerEventCallback("Codestrates.Fragment.Error", ({detail: {messages: messages, fragment: fragment}})=>{
            self.handleMessages(messages, "error", fragment);
        });

        EventSystem.registerEventCallback("Codestrates.Fragment.Log", ({detail: {messages: messages, fragment: fragment}})=>{
            self.handleMessages(messages, "log", fragment);
        });

        EventSystem.registerEventCallback("Codestrates.Fragment.Warn", ({detail: {messages: messages, fragment: fragment}})=>{
            self.handleMessages(messages, "warn", fragment);
        });
    }

    handleMessages(messages, type, fragment) {
        let li = document.createElement("li");
        li.classList.add("cauldron-console-entry");
        
        let source = document.createElement("span");
        source.classList.add("cauldron-console-source");
        let sourceName = "";

        if (fragment){
            source.appendChild(IconRegistry.createIcon(["code-fragment:"+fragment.type, "mdc:insert_drive_file"]));
            if (fragment.html[0].getAttribute("name")) sourceName = fragment.html[0].getAttribute("name")+" ";
            if (fragment.html[0].id) sourceName += "#"+fragment.html[0].id;
            if (sourceName==="") sourceName = fragment.html[0].tagName.toLowerCase();

            new CaviTouch(source);

            source.addEventListener("caviTap", ()=>{
                TreeBrowser.findAllTreeBrowsers().forEach((tb)=>{
                    tb.findTreeNodeForContext(fragment.html[0]).forEach((tn)=>{
                        tn.reveal();
                        tn.select();
                    });
                });
            });

            source.addEventListener("caviDoubleTap", ()=>{
                TreeBrowser.findAllTreeBrowsers().forEach((tb)=>{
                    tb.findTreeNodeForContext(fragment.html[0]).forEach((tn)=>{
                        tn.triggerAction();
                    });
                });
            });
        }
        let sourceTitle = document.createElement("span");
        sourceTitle.textContent = sourceName;
        source.appendChild(sourceTitle);
        li.appendChild(source);

        switch(type) {
            case "log":
                li.classList.add("cauldron-console-entry-log");
                break;
            case "error":
                li.classList.add("cauldron-console-error");
                break;
            case "warn":
                li.classList.add("cauldron-console-warn");
                break;
        }

        messages.forEach((msg)=>{
            let item = document.createElement("span");
            if(typeof msg === "object") {
                function parseDom(dom) {
                    let tagName = dom.tagName.toLowerCase();

                    let attributes = "";

                    Array.from(dom.attributes).forEach((attr)=>{
                        if(attr.specified) {
                            attributes += " "+attr.name+"='"+attr.value+"'";
                        }
                    });

                    let result = "<"+tagName+attributes+"></"+tagName+">";

                    return result;
                }

                if (msg instanceof Element) {
                    item.textContent = parseDom(msg);
                    item.classList.add("cauldron-console-entry-dom");
                } else if (msg instanceof StackWalker.StackTrace){
                    item.textContent = msg.extraReason;
                    let trace = document.createElement("ul");
                    trace.classList.add("cauldron-console-entry-stacktrace");

                    let stack = msg.stack;
                    stack = StackWalker.compactify(msg.stack);

                    stack.forEach((stackLine)=>{
                        let li = document.createElement("li");
                        li.textContent = stackLine.method + (stackLine.lineNumber != null?":" + stackLine.lineNumber:"");
                        trace.appendChild(li);
                    });
                    item.appendChild(trace);
                    item.classList.add("cauldron-console-entry-object", "cauldron-console-entry-folded");
                    item.addEventListener("click", ()=>{
                        item.classList.toggle("cauldron-console-entry-folded");
                    });
                } else {
                    let cache = [];

                    function convertObject(obj) {
                        if (obj instanceof Error) {
                            obj = obj.toJSON();
                        }

                        if (obj instanceof Set) {
                            obj = {
                                "Set": Array.from(obj)
                            };
                        }

                        if (obj instanceof Map) {
                            let objMap = {};

                            obj.forEach((value, key) => {
                                objMap[key] = value;
                            });

                            obj = {
                                "Map": objMap
                            };
                        }

                        return obj;
                    }

                    item.textContent = JSON.stringify(msg, (key, value) => {
                        if (typeof value === "object" && value != null) {
                            if (value instanceof Element) {
                                return parseDom(value);
                            }

                            if(cache.includes(value)) {
                                return;
                            }

                            cache.push(value);

                            return convertObject(value);
                        }

                        return value;
                    }, 2);;
                    item.classList.add("cauldron-console-entry-object", "cauldron-console-entry-folded");
                    item.addEventListener("click", ()=>{
                        item.classList.toggle("cauldron-console-entry-folded");
                    });
                }
            } else {
                item.textContent = msg;
                item.classList.add("cauldron-console-entry-text");
            }

            li.appendChild(item);
        });

        this.consoleUl.appendChild(li);
        this.html.scrollTo(0, this.html.scrollHeight);
    }
};

</script>

                <style id="main-style">
/**
 *  Console Styles
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
.cauldron-console-content {
  width: 100%;
  height: 100%;
  overflow: auto;
  font-size: 0.9em; }
  .cauldron-console-content ul {
    margin: 0;
    padding: 0; }
  .cauldron-console-content .cauldron-console-entry {
    font-family: monospace;
    list-style: none;
    padding: 1px 0.5em 1px 0;
    border-bottom: 1px solid rgba(100, 100, 100, 0.08); }
    .cauldron-console-content .cauldron-console-entry.cauldron-console-entry-filtered {
      display: none; }
    .cauldron-console-content .cauldron-console-entry .cauldron-console-source {
      font-size: 0.9em;
      cursor: pointer;
      margin-right: 0.5em;
      background: rgba(100, 100, 100, 0.1);
      display: inline-flex;
      align-items: center;
      padding: 0.25em;
      vertical-align: sub; }
      .cauldron-console-content .cauldron-console-entry .cauldron-console-source .wsc-registry-icon {
        height: 1.5em;
        width: 1.25em;
        margin-right: 0.25em; }
    .cauldron-console-content .cauldron-console-entry.cauldron-console-error {
      color: red;
      background: rgba(255, 0, 0, 0.05); }
      .cauldron-console-content .cauldron-console-entry.cauldron-console-error .cauldron-console-entry-object {
        color: darkred; }
        .cauldron-console-content .cauldron-console-entry.cauldron-console-error .cauldron-console-entry-object::before {
          color: darkred; }
    .cauldron-console-content .cauldron-console-entry.cauldron-console-warn {
      color: #756600;
      background: rgba(250, 242, 85, 0.1); }
      .cauldron-console-content .cauldron-console-entry.cauldron-console-warn .cauldron-console-entry-object {
        color: #4f4500; }
        .cauldron-console-content .cauldron-console-entry.cauldron-console-warn .cauldron-console-entry-object::before {
          color: #4f4500; }
    .cauldron-console-content .cauldron-console-entry .cauldron-console-entry-dom {
      color: hotpink;
      display: inline-block; }
    .cauldron-console-content .cauldron-console-entry .cauldron-console-entry-text {
      padding-right: 1em; }
    .cauldron-console-content .cauldron-console-entry .cauldron-console-entry-object {
      white-space: pre;
      display: block; }
      .cauldron-console-content .cauldron-console-entry .cauldron-console-entry-object.cauldron-console-entry-folded {
        white-space: nowrap;
        text-overflow: ellipsis;
        max-width: 100%;
        overflow: hidden;
        display: block;
        height: 1em; }
        .cauldron-console-content .cauldron-console-entry .cauldron-console-entry-object.cauldron-console-entry-folded::before {
          content: "[+]"; }
      .cauldron-console-content .cauldron-console-entry .cauldron-console-entry-object::before {
        content: "[-]"; }
</style>

            </div>
            <div class="package" id="CauldronInspector">
                <script id="inspector-script" type="disabled">
/**
 *  CauldronInspector
 *  Visual inspector of various elements that can be edited in Cauldron
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

class CauldronInspector {
    constructor(){
        let self = this;

        this.html = document.createElement("div");
        this.html.classList.add("cauldron-inspector");
        
        this.fields = document.createElement("div");
        this.fields.classList.add("cauldron-inspector-fields");
        this.html.appendChild(this.fields);
        this.currentSelection = null;

        this.currentInspectElements = [];

        EventSystem.registerEventCallback("TreeBrowser.Selection", ({detail: {selection: selection}})=>{
            self.inspect(selection);
        });
    }

    /**
     *
     * @param {TreeNode} selection
     */
    inspect(selection) {
        let self = this;
        this.currentSelection = selection;

        this.html.scrollTo(0, 0);

        let inspectorElements = null;
        for(let inspector of CauldronInspector.contentBindings) {
            inspectorElements = inspector.contentBinding.inspect(selection, this);

            if(inspectorElements != null) {
                //First inspector to return something wins.
                break;
            }
        }

        //Remove old elements
        this.currentInspectElements.forEach((inspectElement)=>{
            inspectElement.destroy();
        });

        this.currentInspectElements = [];

        if(inspectorElements != null) {
            inspectorElements.forEach((element)=>{
                self.fields.append(element.html);
                self.currentInspectElements.push(element);
            });
        }
    }
    
    reinspect(){
        this.inspect(this.currentSelection);
    }

    /**
     * Register a content binding for the CauldronInspector component
     * @param contentBinding
     * @param {Number} priority
     */
    static registerContentBinding(contentBinding, priority) {
        CauldronInspector.contentBindings.push({
            contentBinding: contentBinding,
            priority: priority
        });

        //Sort decorators according to priority
        CauldronInspector.contentBindings.sort((i1, i2)=>{
            return i2.priority - i1.priority;
        });
    }
};

CauldronInspector.contentBindings = [];

window.Cauldron.CauldronInspector = CauldronInspector;

class InspectorSegment {    
    constructor(name, parentList){
        this.html = document.createElement("div");
        this.html.classList.add("cauldron-inspector-section");
        let sectionHeader = document.createElement("div");
        sectionHeader.classList.add("cauldron-inspector-header");
        sectionHeader.innerText = name;
        this.html.appendChild(sectionHeader);
        this.parentList = parentList;
    }    
    
    push(element){
        this.parentList.push(element);
    }

    destroy() {
        this.html.remove();
    }
}
window.Cauldron.InspectorSegment = InspectorSegment;


class InspectorElement {
    constructor() {
        this._html = document.createElement("div");
        this._html.classList.add("cauldron-inspector-element");
    }
    
    setFailing(failing){
        if (failing){
            if (!this._html.classList.contains("failing-element")) this._html.classList.toggle("failing-element");
        } else {
            if (this._html.classList.contains("failing-element")) this._html.classList.toggle("failing-element");
        }
    }

    get html() {
        return this._html;
    }

    destroy() {
        this.html.remove();
    }
}
window.Cauldron.InspectorElement = InspectorElement;

class InspectorHTMLElement extends InspectorElement {
    constructor(html) {
        super();

        this.html.appendChild(html);
    }
}

window.Cauldron.InspectorHTMLElement = InspectorHTMLElement;

</script>

                <script id="InspectorHTMLBinding-script" type="disabled">
/**
 *  Inspector HTML Bindings
 *  Visual inspector of HTML and DOM elements
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
    
class InspectorHTMLBinding {
    /**
     * Inspects the given TreeNode and if supported, returns a map of editable attributes
     * @param {TreeNode} treeNode
     * @returns {Cauldron.InspectorElement[]}
     */
    static inspect(treeNode, inspector) {
        if(treeNode.type === "DomTreeNode") {
            let elements = [];

            InspectorHTMLBinding.focusEditor = new Cauldron.InspectorAttributeEditor(treeNode.context, "id");
            
            let primaryFold = new Cauldron.InspectorSegment("Attributes", elements);
            elements.push(primaryFold);
            primaryFold.push(InspectorHTMLBinding.focusEditor);
            let primaryAttributes = ["class", "name"];
            
            switch (treeNode.context.tagName){
                case "IMG":
                    primaryAttributes = [...primaryAttributes, "src", "alt", "width", "height"];
                    break;
                case "SCRIPT":
                    primaryAttributes = [...primaryAttributes, "src", "type"];
                    break;
                case "IFRAME":
                    primaryAttributes.push("src");
                    break;
                case "A":
                    primaryAttributes.push("href");
                    break;
                case "INPUT":
                    primaryAttributes = [...primaryAttributes, "type", "value"];
                    break;
                case "OPTION":
                    primaryAttributes.push("value");
                    break;
                case "LINK":
                    primaryAttributes = [...primaryAttributes, "type", "rel", "href"];
                    break;
                case "LABEL":
                    primaryAttributes.push("for");
                    break;
                case "BUTTON":
                    primaryAttributes.push("type");
                    break;
                case "FORM":
                    primaryAttributes = [...primaryAttributes, "action", "method"];
                    break;
            }                        
            for (let attribute of primaryAttributes){
                primaryFold.push(new Cauldron.InspectorAttributeEditor(treeNode.context, attribute));                
            }
            primaryAttributes.push("id"); // We already added this manually

            // Add other attributes present which are not primary ones
            let fold = new Cauldron.InspectorSegment("Additional Attributes", elements);
            elements.push(fold);
            for (let attributeEntry of treeNode.context.attributes){
                if (!primaryAttributes.includes(attributeEntry.name)){
                    fold.push(new Cauldron.InspectorAttributeEditor(treeNode.context, attributeEntry.name));                
                }
            }
            fold.push(new Cauldron.InspectorAttributeAdder(treeNode.context, inspector));
            
            return elements;
        }

        return null;
    }
}

window.Cauldron.InspectorHTMLBinding = InspectorHTMLBinding;

Cauldron.CauldronInspector.registerContentBinding(InspectorHTMLBinding, 10);

class InspectorAttributeAdder extends Cauldron.InspectorElement {
    constructor(domElement, inspector){
        super();
        let label = document.createElement("label");
        label.classList.add("cauldron-inspector-element-label");        
        let adderButton = document.createElement("button");
        adderButton.innerText = "Add Attribute";
        adderButton.classList.add("cauldron-inspector-element-editor");
        this.html.append(label);
        this.html.append(adderButton);
        
        adderButton.addEventListener("click", ()=>{
            let attributeName = prompt("Attribute Name:");
            if (attributeName !== null && attributeName!==""){
                domElement.setAttribute(attributeName,"");
                inspector.reinspect();
            }
        });
    }
}
window.Cauldron.InspectorAttributeAdder = InspectorAttributeAdder;


class InspectorAttributeEditor extends Cauldron.InspectorElement {
    /**
     *
     * @param {Element} domElement
     * @param {String} attrName
     * @param {String} overrideLabel
     */
    constructor(domElement, attrName, overrideLabel= null) {
        super();

        let self = this;

        this.domElement = domElement;
        this.attrName = attrName;

        this.editor = document.createElement("input");
        this.editor.classList.add("cauldron-inspector-element-field");
        this.editor.classList.add("cauldron-inspector-element-editor");
        this.editor.setAttribute("contenteditable", "true");
        this.editor.setAttribute("spellcheck", "false");

        this.label = document.createElement("span");
        this.label.classList.add("cauldron-inspector-element-label");
        this.label.textContent = overrideLabel==null?this.attrName:overrideLabel;

        this.html.append(this.label);
        this.html.appendChild(this.editor);
        this.html.classList.add("inspector-htmlnode");

        this.editor.value = this.domElement.getAttribute(this.attrName);

        this.observer = new MutationObserver((mutations)=>{
            //handleMutations(mutations);
        });

        function handleMutations(mutations) {
            //Attribute changed, update editor
            if(mutations.length > 0) {
                self.editor.value = self.domElement.getAttribute(self.attrName);
            }
        }

        function startObserver() {
            self.observer.observe(self.domElement, {
                attributes: true,
                attributeFilter: [self.attrName]
            });
        }

        function pauseObserver() {
            let mutationRecords = self.observer.takeRecords();
            self.observer.disconnect();
            handleMutations(mutationRecords);
        }

        startObserver();

        this.html.addEventListener("keydown", (event)=>{
            if(event.code === "Enter") {
                event.preventDefault();
            }
        });

        this.html.addEventListener("input", (evt)=>{
            pauseObserver();
            self.domElement.setAttribute(self.attrName, self.editor.value);
            setTimeout(()=>{
                startObserver();
            }, 0);
        });
    }

    destroy() {
        super.destroy();
        this.observer.disconnect();
    }
    
    focus(){
        this.editor.select();
    }
}

window.Cauldron.InspectorAttributeEditor = InspectorAttributeEditor;

EventSystem.registerEventCallback("TreeBrowser.Keyup", ({detail: {evt: evt, treeNode: treeNode}})=>{
    console.log(evt);
    if(evt.key === "F2" && InspectorHTMLBinding.focusEditor) {
        InspectorHTMLBinding.focusEditor.focus();
    }
});   

</script>

                <script id="InspectorAssetBinding-script" type="disabled">
/**
 *  Asset Inspector
 *  Visual inspector for webstrate assets
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

class InspectorAssetBinding {
    /**
     * Inspects the given TreeNode and if supported, returns a map of inspector elements
     * @param {TreeNode} treeNode
     * @returns {Cauldron.InspectorElement[]}
     */
    static inspect(treeNode) {
        if(treeNode.type === "AssetNode" || treeNode.type === "AssetContainer") {
            let elements = [];

            elements.push(new Cauldron.InspectorAssetPreviewElement(treeNode));
            elements.push(new Cauldron.InspectorAssetAttributeElement(treeNode, "fileName", "name"));
            elements.push(new Cauldron.InspectorAssetAttributeElement(treeNode, "v", "version"));
            elements.push(new Cauldron.InspectorAssetAttributeElement(treeNode, "fileSize", "size", true));
            elements.push(new Cauldron.InspectorAssetAttributeElement(treeNode, "mimeType", "type"));

            let downloadButton = ButtonSystem.ButtonFactory.createButton("Download", {
                onAction: ()=>{
                    EventSystem.triggerEvent("Cauldron.Asset.Download", {
                        asset: treeNode.context
                    });
                },
                style: "outlined",
                icon: IconRegistry.createIcon("mdc:get_app"),
            });

            elements.push(new Cauldron.InspectorHTMLElement(downloadButton.html));

            downloadButton.html.style.gridColumn = "1/3";

            return elements;
        }

        return null;
    }
}

window.Cauldron.InspectorAssetBinding = InspectorAssetBinding;

Cauldron.CauldronInspector.registerContentBinding(InspectorAssetBinding, 10);

class InspectorAssetAttributeElement extends Cauldron.InspectorElement {
    /**
     *
     * @param {TreeNode} treeNode
     * @param {String} attrName
     * @param {String} overrideLabel
     */
    constructor(treeNode, attrName, overrideLabel = null, formatSize = false) {
        super();

        let self = this;

        this.formatSize = formatSize;

        this.treeNode = treeNode;
        this.attrName = attrName;

        this.label = document.createElement("span");
        this.label.classList.add("cauldron-inspector-element-label");
        this.label.textContent = overrideLabel==null?this.attrName+":":overrideLabel;

        this.content = document.createElement("span");
        this.content.classList.add("cauldron-inspector-element-field");

        this.html.appendChild(this.label);
        this.html.appendChild(this.content);

        this.handleAssetUpdated = function() {
            self.assetUpdated();
        };

        this.treeNode.registerOnDecoratedCallback(this.handleAssetUpdated);

        this.assetUpdated();
    }

    destroy() {
        super.destroy();
        this.treeNode.deregisterOnDecoratedCallback(this.handleAssetUpdated);
    }

    assetUpdated() {
        let value = this.treeNode.context[this.attrName];

        if(this.formatSize) {
            let unit = "B";

            value = parseInt(value);

            if(value > 1024) {
                value /= 1024;
                unit = "KiB";

                if(value > 1024) {
                    value /= 1024;
                    unit = "MiB";

                    if(value > 1024) {
                        value /= 1024;
                        unit = "GiB";

                        if(value > 1024) {
                            value /= 1024;
                            unit = "TiB";
                        }
                    }
                }
            }



            value = value.toFixed(2) + " " + unit;
        }

        this.content.textContent = value;
    }
}

window.Cauldron.InspectorAssetAttributeElement = InspectorAssetAttributeElement;

class InspectorAssetPreviewElement extends Cauldron.InspectorElement {
    constructor(treeNode) {
        super();
        let self = this;

        this.treeNode = treeNode;

        this.handleAssetUpdated = function() {
            self.assetUpdated();
        };

        this.treeNode.registerOnDecoratedCallback(this.handleAssetUpdated);

        this.assetUpdated();
        this.html.classList.add("inspector-asset");
    }

    destroy() {
        super.destroy();
        this.treeNode.deregisterOnDecoratedCallback(this.handleAssetUpdated);
    }

    assetUpdated() {
        while(this.html.firstChild) this.html.firstChild.remove();

        let element = null;       
        switch(this.treeNode.context["mimeType"]){
            case "image/svg+xml":
            case "image/gif":
            case "image/jpeg":
            case "image/bmp":
            case "image/x-icon":
            case "image/png":
                element = document.createElement("img");
                element.src = location.href.split("?")[0] + this.treeNode.context["fileName"];
                break;
                
            case "video/x-matroska":
            case "video/quicktime":
            case "video/mp4":
            case "video/webm":
            case "video/opgg":
                element = document.createElement("video");
                element.src = location.href.split("?")[0] + this.treeNode.context["fileName"];
                element.setAttribute("controls", true);
                break;
                
            case "audio/mp3":
            case "audio/wav":
            case "audio/ogg":
            case "audio/mpeg":
                element = document.createElement("audio");
                element.src = location.href.split("?")[0] + this.treeNode.context["fileName"];
                element.setAttribute("controls", true);
                break;

            default:
                console.log("Unhandled mimeType:", this.treeNode.context["mimeType"]);
                return;
        }
        
        element.classList.add("cauldron-inspector-element-asset-preview");
        element.setAttribute("tabindex","0");
        this.html.appendChild(element);

    }
}

window.Cauldron.InspectorAssetPreviewElement = InspectorAssetPreviewElement;

</script>

                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "Cauldron Inspector",
    "description": "Provides a list view of editable attributes and parameters",
    "dependencies": [
        "#CauldronNamespace"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",    
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <style id="main-style">
/**
 *  CauldronInspector Styles
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
@keyframes cauldron-inspector-asset-preview-appears {
  from {
    opacity: 0;
    transform: scaleY(0.2); }
  to {
    opacity: 1;
    transform: scaleY(1); } }

.cauldron-inspector {
  overflow-y: auto;
  height: 100%;
  font-size: 0.9em; }
  .cauldron-inspector .cauldron-inspector-fields {
    display: grid;
    grid-template-columns: [label] 0fr [field] 1fr [extras] 0fr; }
    .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-section {
      grid-column-start: 1;
      grid-column-end: -1; }
      .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-section:not(:first-child) {
        padding-top: 1em; }
      .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-section .cauldron-inspector-header {
        padding-left: 0.5em;
        opacity: 0.7;
        border-bottom: 1px solid rgba(0, 0, 0, 0.2); }
    .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-element {
      display: contents; }
      .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-element .cauldron-inspector-element-label {
        grid-column-start: label;
        text-align: right;
        padding: 0.25em 0.5em;
        background: rgba(100, 100, 100, 0.1);
        opacity: 0.7;
        display: flex;
        align-items: center;
        justify-content: right; }
      .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-element:focus-within .cauldron-inspector-element-label {
        opacity: 1; }
      .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-element.failing-element * {
        background: red !important; }
      .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-element .cauldron-inspector-element-field {
        background: rgba(100, 100, 100, 0.1);
        grid-column-start: field;
        justify-self: stretch;
        padding: 0.25em;
        display: flex; }
      .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-element .cauldron-inspector-element-editor {
        background: transparent;
        border: 0;
        border-bottom: 1px solid rgba(100, 100, 100, 0.15);
        min-width: 2em;
        width: 95%;
        color: var(--mdc-theme-primary-on-background); }
      .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-element .cauldron-inspector-element-asset-preview {
        grid-column: 1/-1;
        height: 5em;
        max-width: 100%;
        justify-self: center;
        cursor: pointer;
        position: relative; }
        .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-element .cauldron-inspector-element-asset-preview:focus, .cauldron-inspector .cauldron-inspector-fields .cauldron-inspector-element .cauldron-inspector-element-asset-preview:focus-within {
          position: fixed;
          left: 10%;
          width: 80%;
          top: 10%;
          height: 80%;
          background: rgba(0, 0, 0, 0.8);
          box-shadow: 0 0 1em;
          z-index: 9000;
          animation: 0.1s cauldron-inspector-asset-preview-appears ease-out; }
</style>

            </div>
            <div class="package" id="CauldronEditor">
                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "Cauldron Editor",
    "description": "Component that can show a Codestrates Editor",
    "dependencies": [
        "#CauldronNamespace"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",    
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <script id="editor-component-script" type="disabled">
/**
 *  CauldronEditor
 *  Binding for editing Codestrate Fragments
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/**
 * CauldronEditor is a component that can edit Codestrate Fragments
 * @memberof Cauldron
 */
class CauldronEditor {
    /**
     * Create a new CauldronEditor that edits the given Fragment
     * @param {Fragments.Fragment} fragment - The fragment to edit
     */
    constructor(fragment, options) {
        let self = this;

        /** @member {Fragments.Fragment} - The fragment this CauldronEditor edits */
        this.fragment = fragment;

        this.options = options;

        /** @member {Element} - The DOM element of this CauldronEditor */
        this.html = document.createElement("div");
        this.html.classList.add("cauldron-editor-component");

        /** @member {Editors.Editor} - The codestrates editor of this CauldronEditor */
        this.editor = EditorManager.createEditor(fragment, {
            editor: this.options.editorClass, 
            theme: Cauldron.CauldronSettings.getTheme(),
            mode: "component"
        })[0];

        this.toolbar = document.createElement("div");
        this.toolbar.classList.add("cauldron-editor-component-toolbar");
        this.southArea = document.createElement("div");
        this.southArea.classList.add("cauldron-editor-component-south");

        this.toolbarMenu = MenuSystem.MenuManager.createMenu("Cauldron.Editor.Toolbar", {
            context: self.fragment,
            keepOpen: true,
            layoutDirection: MenuSystem.Menu.LayoutDirection.HORIZONTAL,
            defaultFocus: false
        });

        this.toolbar.appendChild(this.toolbarMenu.html);

        this.html.appendChild(this.toolbar);

        if(this.editor != null) {
            this.html.appendChild(this.editor.html[0]);
        } else {
            //Show warning instead of editor
            let warningDiv = document.createElement("div");
            this.html.appendChild(warningDiv);
            warningDiv.textContent = "No suitable editors could be found for fragment type ["+this.fragment.type+"] - Maybe require more editors.";
        }

        this.html.appendChild(this.southArea);

        this.fragment.registerOnAutoChangedHandler(()=>{
            //Update menu when fragment changes
            self.toolbarMenu.update();
        });

        function unloadHandler() {
            try {
                self.html.glContainer.close();
                self.destroy();
            } catch(e) {
                //Silent ignore
            }
            self.fragment.unRegisterOnFragmentUnloadedHandler(unloadHandler);
        }

        this.fragment.registerOnFragmentUnloadedHandler(unloadHandler);

        this.html.addEventListener("keydown", (evt)=> {
            if(evt.key === "s" && evt.ctrlKey) {
                evt.preventDefault();
            }
        });

        this.clientIcons = new Map();

        this.clientIconArea = document.createElement("div");
        this.clientIconArea.classList.add("cauldron-editor-component-clientarea");
        this.toolbar.insertBefore(this.clientIconArea, self.toolbar.firstChild);

        this.eventDeleters = [];

        this.eventDeleters.push(EventSystem.registerEventCallback("Collaboration.FragmentFocused", ({detail: { client:client, fragment: fragment}})=>{
            if(fragment === self.fragment) {
                self.addClientIcon(client);
            }
        }));

        this.eventDeleters.push(EventSystem.registerEventCallback("Collaboration.FragmentSelection", ({detail: { client:client, fragment: fragment, selection: selection}})=>{
            if(fragment === self.fragment) {
                if(self.editor != null) {
                    self.editor.setForeignSelection(client.id, selection);
                }
                self.addClientIcon(client);
            }
        }));

        this.eventDeleters.push(EventSystem.registerEventCallback("Collaboration.FragmentUnfocused", ({detail: { client:client, fragment: fragment}})=>{
            if(fragment === self.fragment) {
                if(self.editor != null) {
                    self.editor.setForeignSelection(client.id, null);
                }
                self.removeClientIcon(client);
            }
        }));

        // Handle live theme updates
        this.eventDeleters.push(EventSystem.registerEventCallback("Cauldron.Theme", (event)=>{
            if(self.editor !== null && event.detail.theme !== null) {
                self.editor.setTheme(event.detail.theme);
            }
        }));


        if(this.editor != null) {
            this.setupDropZone();

            //Setup settings on editor opened, and settings updated
            EventSystem.registerEventCallback("Cauldron.Settings.Updated", ({detail: settings}) => {
                self.editor.setWordwrap(Cauldron.CauldronSettings.getWordwrap());
            });

            EventSystem.registerEventCallback("Codestrates.Editor.Opened", ({detail: {editor}})=>{
                editor.setWordwrap(Cauldron.CauldronSettings.getWordwrap());
            });
        }
    }

    addClientIcon(client) {
        if(!this.clientIcons.has(client.id)) {
            let icon = Cauldron.Collaboration.getClientIcon(client.id);
            this.clientIcons.set(client.id, icon);
            this.clientIconArea.appendChild(icon);
        }
    }

    removeClientIcon(client) {
        if(this.clientIcons.has(client.id)) {
            let icon = this.clientIcons.get(client.id);
            this.clientIcons.delete(client.id);
            icon.remove();
        }
    }

    onSizeChanged() {
        if(this.editor != null) {
            this.editor.onSizeChanged();
        }
    }
    
    get title() {
        let content = "";
        let name = this.fragment.html[0].getAttribute("name");
        if (name != null && name != ""){
            content = name+" ";
        } else if(this.fragment.html[0].id != null && this.fragment.html[0].id!="") {
            content += "#"+this.fragment.html[0].id;
        }
        if (!content){
            content = this.fragment.html[0].tagName.toLowerCase();
        }
        if(typeof this.options.titleWrapper === "function") {
            return this.options.titleWrapper(content);
        } else {
            return content;
        }
    }
    
    get tooltip(){
        let type = this.fragment.type;
        let id = this.fragment.html[0].getAttribute("id");

        let tooltip = "Fragment";

        if (id != null && id.trim() !== "") {
            tooltip += "#" + id;
        }

        tooltip += " [" + type + "]";
        return tooltip;
    }

    focus() {
        if(this.editor != null) {
            this.editor.focus();
        }
    }

    setLine(line, column=1) {
        if(this.editor != null) {
            this.editor.setLine(line, column);
        }
    }

    destroy() {
        if(this.editor != null) {
            this.editor.unload();
        }

        this.editor = null;

        this.eventDeleters.forEach((deleter)=>{
            deleter.delete();
        });
    }

    setupDropZone() {
        let self = this;

        new CaviDroppableHTML5(this.html, {
            onDragLeave: (evt)=>{
            },
            onDragOver: (evt)=>{
                evt.dataTransfer.dropEffect = "none";

                if(evt.dataTransfer.types.includes("treenode/uuid")) {
                    let dragUUID = null;

                    evt.dataTransfer.types.forEach((type)=>{
                        if(type.indexOf("treenodedata/uuid") !== -1) {
                            dragUUID = type.split("|")[1];
                        }
                    });

                    let dragged = document.querySelector("[transient-drag-id='" + dragUUID + "']");
                    if (dragged != null && dragged.treeNode != null) {
                        let allowedRequireFragments = ["text/javascript", "text/typescript", "text/ruby", "text/python", "application/x-lua"];

                        if (dragged.treeNode.context.matches != null && dragged.treeNode.context.matches("code-fragment") && dragged.treeNode.context.hasAttribute("id") && allowedRequireFragments.includes(self.fragment.type)) {
                            evt.dataTransfer.dropEffect = "copy";
                        } else if(dragged.treeNode.type === "AssetNode" && allowedRequireFragments.includes(self.fragment.type) && (dragged.treeNode.context.fileName.endsWith(".js") || dragged.treeNode.context.fileName.endsWith(".css") )) {
                            evt.dataTransfer.dropEffect = "copy";
                        } else if(dragged.treeNode.type === "AssetNode" && self.fragment.type === "wpm/descriptor") {
                            evt.dataTransfer.dropEffect = "copy";
                        }
                    }
                }
            },
            onDrop: (evt, dropEffect)=>{
                let otherWebstrate = null;

                if(evt.dataTransfer.types.includes("treenode/href")) {
                    otherWebstrate = evt.dataTransfer.getData("treenode/href");
                }

                if(evt.dataTransfer.types.includes("treenode/uuid")) {
                    try {
                        let dragUUID = evt.dataTransfer.getData("treenode/uuid");
                        let dragged = document.querySelector("[transient-drag-id='" + dragUUID + "']");
                        if (dragged != null && dragged.treeNode != null) {
                            //Found the dragged TreeNode

                            let requireData = null;

                            if(dragged.treeNode.type === "DomTreeNode") {
                                requireData = cQuery(dragged.treeNode.context).data("Fragment");
                            } else if(dragged.treeNode.type === "AssetNode") {
                                requireData = dragged.treeNode.context;

                                if(self.fragment.type === "wpm/descriptor") {
                                    //Special insert here
                                    self.fragment.require().then((descJson)=>{
                                        if(!descJson.assets.includes(requireData.fileName)) {
                                            descJson.assets.push(requireData.fileName);
                                            self.fragment.raw = JSON.stringify(descJson, null, 2);
                                        }
                                    });
                                    return;
                                }
                            }

                            let requireLine = self.createRequireFromType(self.fragment.type, requireData);
                            self.editor.insertAtSelection(requireLine);
                            return;
                        }
                    } catch(e) {
                        console.log("Error accepting drop as treenode/uuid", e);
                    }
                }

                console.log("No supported data transfers:", evt.dataTransfer.types.slice());

                evt.dataTransfer.types.forEach((type)=>{
                    console.log(type, evt.dataTransfer.getData(type));
                });
            }
        });
    }

    createRequireFromType(type, requireData) {
        let requireLine = null;

        if(requireData instanceof Fragment) {
            let fragmentId = requireData.html[0].getAttribute("id");
            switch(type) {
                case "text/javascript":
                case "text/typescript":
                    requireLine = "let "+fragmentId+" = await Fragment.one(\"#"+fragmentId+"\").require();\n";
                    break;

                case "text/ruby":
                    requireLine = "Native(`Fragment`.JS.one(\"#"+fragmentId+"\").JS.require()).then { |result|\n" +
                        "    result = Native(result);\n" +
                        "}";
                    break;
                case "text/python":
                    requireLine = fragmentId+" = await window.Fragment.one(\"#"+fragmentId+"\").require()\n";
                    break;
                case "application/x-lua":
                    requireLine = "local "+fragmentId+" = pwait(js.global.Fragment:one(\"#"+fragmentId+"\"):require())\n";
                    break;

                default:
                    console.log("Unknown type for require creation: ", type);
            }
        } else if(requireData.fileName != null) {
            //Assume asset if fileName exists
            switch(type) {
                case "text/javascript":
                case "text/typescript":
                    requireLine = "await wpm.requireExternal(\""+location.href+requireData.fileName+"\");\n";
                    break;
                case "text/python":
                    requireLine = "load(\""+location.href+requireData.fileName+"\");\n";
                    break;

                default:
                    console.log("Unknown type for require creation: ", type);
            }
        }

        return requireLine;
    }
}

window.Cauldron.CauldronEditor = CauldronEditor;

</script>

                <style id="main-style">
/**
 *  CauldronEditor Styles
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
.cauldron-editor-component {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column; }
  .cauldron-editor-component .cauldron-editor-component-toolbar {
    background: var(--mdc-theme-surface, rgba(255, 255, 255, 0.6));
    border-bottom: 1px solid #8a8a8a40;
    display: flex;
    justify-content: flex-end;
    opacity: 0.7; }
    .cauldron-editor-component .cauldron-editor-component-toolbar:hover {
      opacity: 1; }
  .cauldron-editor-component .codestrates-editor-core {
    height: 0;
    /** Layouting bug? **/
    flex: 1 1 auto; }
  .cauldron-editor-component .cauldron-editor-component-south {
    background: rgba(255, 255, 255, 0.6);
    display: flex;
    justify-content: flex-start;
    opacity: 0.7; }
    .cauldron-editor-component .cauldron-editor-component-south:not(:empty), .cauldron-editor-component .cauldron-editor-component-south.unsaved-changes {
      border-top: 1px solid #8a8a8a40;
      padding: 0.25em; }
    .cauldron-editor-component .cauldron-editor-component-south.unsaved-changes {
      background-color: rgba(255, 0, 0, 0.5); }
      .cauldron-editor-component .cauldron-editor-component-south.unsaved-changes::before {
        content: "Unsaved changes!"; }
</style>

            </div>

            <div class="package" id="CauldronCollaboration">
                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "Cauldron collabration module",
    "description": "Provides features for showing collaborators in different ways",
    "dependencies": [
        "codestrates-repos #EventSystem"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",    
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <script id="collaboration-script" type="disabled">
/**
 *  Collaboration
 *  A collaboration overlay for showing other connected users' focus in Cauldron
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate */

class Collaboration {

    constructor(numColors) {
        let self = this;

        //Setup colors
        this.availableColors = new Set();

        //Select 16 different colors
        for(let i = 0; i<numColors; i++) {
            this.availableColors.add(Collaboration.selectColor(i, numColors));
        }

        //Setup transient to hold styles
        this.styleTransient = document.createElement("transient");
        this.styleTransient.id = "Collaboration-Styles";
        document.head.appendChild(this.styleTransient);

        //Client map that holds all our known remote clients
        this.clientMap = new Map();

        this.currentFocusFragment = null;
        this.currentSelection = null;

        //Listen for clients leaving
        webstrate.on("clientPart", (remoteClient)=>{
            self.onClientPart(remoteClient);
        });

        //Listen for clients joining
        webstrate.on("clientJoin", (remoteClient)=>{
            self.setupClient(remoteClient);
        });

        //Setup already connected clients
        webstrate.clients.forEach((client)=>{
            if(client === webstrate.clientId) {
                //Ignore self
                return;
            }

            self.setupClient(client);
        });

        this.setupObserver();

        this.setupEventHandlers();

        document.querySelectorAll("code-fragment").forEach((fragment)=>{
            self.handleFragmentFound(fragment);
        });

        webstrate.on("signal", (msg, sender)=>{
            self.handleSignal(msg, sender);
        });
    }

    handleSignal(msg, sender) {
        let self = this;

        //Ignore ourself
        if(sender === webstrate.clientId) {
            return;
        }

        if(msg.cmd != null) {
            switch (msg.cmd) {
                case "Collaboration.UserJoined": {
                    //Someone joined our webstrate, tell them who we are
                    self.sendUserInfoSignal(sender);

                    //Also tell them what we are currently focusing, and selecting
                    self.sendCurrentFocusAndSelection(sender);

                    break;
                }

                case "Collaboration.UserInfo": {
                    let client = self.getClient(sender);
                    client.info = msg.info;

                    break;
                }
            }
        }
    }

    getClient(clientId) {
        let client = this.clientMap.get(clientId);

        if(client == null) {
            client = {
                id: clientId
            };
            this.clientMap.set(clientId, client);
        }

        return client;
    }

    onClientPart(remoteClient) {
        let client = this.getClient(remoteClient);

        if(client.style != null) {
            client.style.remove();
            this.availableColors.add(client.color);
        }

        if(client.focusFragment != null) {
            EventSystem.triggerEvent("Collaboration.FragmentUnfocused", {
                client: client,
                fragment: client.focusFragment
            });
        }

        //Remove client info
        this.clientMap.delete(remoteClient);
    }

    setupEventHandlers() {
        let self = this;

        EventSystem.registerEventCallback("Collaboration.FragmentFocused", ({detail: {client: client, fragment: fragment}})=>{
            if(client.deleter != null) {
                client.deleter.delete();
            }

            let deleter = MenuSystem.MenuManager.registerMenuItem("TreeBrowser.TreeNode.MetaMenu", {
                icon: self.getClientIcon(client.id),
                onOpen: (menu, item)=>{
                    return menu.context === fragment.html[0];
                }
            });

            client.deleter = deleter;
        });

        EventSystem.registerEventCallback("Collaboration.FragmentUnfocused", ({detail: {client: client, fragment: fragment, userName: userName}})=>{
            if(client.deleter != null) {
                client.deleter.delete();
                client.deleter = null;
            }
        });

        EventSystem.registerEventCallback("Codestrates.Editor.Selection", ({detail: {editor: editor, selection: selection}})=>{
            if(self.currentFocusFragment !== editor.fragment) {
                self.setCurrentFocusedFragment(editor.fragment);
            }

            self.setCurrentSelection(selection);
        });

        EventSystem.registerEventCallback("Codestrates.Editor.Focus", ({detail: {editor: editor}})=>{
            if(self.currentFocusFragment !== editor.fragment) {
                self.setCurrentFocusedFragment(editor.fragment);
            }
        });

        EventSystem.registerEventCallback("Codestrates.Editor.Blur", ({detail: {editor: editor}})=>{
            if(self.currentFocusFragment === editor.fragment) {
                self.setCurrentFocusedFragment(null);
            }
        });

        EventSystem.registerEventCallback("Codestrates.Editor.Opened", ({detail: {editor: editor}})=>{
            self.clientMap.forEach((client)=>{
                if(client.focusFragment === editor.fragment) {
                    EventSystem.triggerEvent("Collaboration.FragmentSelection", {
                        client: client,
                        fragment: editor.fragment,
                        selection: client.selection
                    });
                }
            });
        });
    }

    setCurrentFocusedFragment(fragment) {
        if(this.currentFocusFragment != null) {
            //Send unfocus signal
            this.sendUnfocusedSignal(this.currentFocusFragment);
        }

        this.currentFocusFragment = fragment;

        //Send focus signal
        if(this.currentFocusFragment != null) {
            this.sendFocusedSignal(this.currentFocusFragment);
        }
    }

    setCurrentSelection(selection) {
        this.currentSelection = selection;
        this.sendSelectionSignal(this.currentFocusFragment);
    }

    getUserInfo() {
        return {
            userName: webstrate.user.displayName!=null?webstrate.user.displayName:webstrate.clientId,
            avatar:webstrate.user.avatarUrl!=null?webstrate.user.avatarUrl:null
        }
    }

    sendCurrentFocusAndSelection(receiver) {
        if(this.currentFocusFragment != null) {
            this.sendFocusedSignal(this.currentFocusFragment, receiver);
        }
        if(this.currentSelection != null) {
            this.sendSelectionSignal(this.currentFocusFragment, receiver);
        }
    }

    /**
     * Send our user info
     * @param receiver - The webstrate client to receive our user info, if null, everyone gets it
     */
    sendUserInfoSignal(receiver) {
        this.sendSignal({
            msg: {
                cmd: "Collaboration.UserInfo",
                info: this.getUserInfo()
            },
            receiver: receiver
        });
    }

    sendSelectionSignal(fragment, receiver) {
        this.sendSignal({
            msg: {
                cmd: "Collaboration.Fragment.Selection",
                selection: this.currentSelection
            },
            receiver: receiver,
            fragment: fragment
        });
    }

    sendSignal(options) {
        let channel = webstrate;

        if(options.fragment != null) {
            channel = options.fragment.html[0].webstrate;
        }

        if(channel != null) {
            if(options.receiver != null) {
                channel.signal(options.msg, [options.receiver]);
            } else {
                channel.signal(options.msg);
            }
        }
    }

    /**
     * Tell everyone that a fragment has been unfocused
     * @param fragment - The fragment that was unfocused
     */
    sendUnfocusedSignal(fragment, receiver) {
        this.sendSignal({
            msg: {
                cmd: "Collaboration.Fragment.Unfocused"
            },
            receiver: receiver,
            fragment: fragment
        });
    }

    /**
     * Tell everyone that a fragment has been focused
     * @param fragment - The fragment that was unfocused
     */
    sendFocusedSignal(fragment, receiver) {
        this.sendSignal({
            msg: {
                cmd: "Collaboration.Fragment.Focused"
            },
            receiver: receiver,
            fragment: fragment
        });
    }

    /**
     * Tell everyone that we joined the webstrate
     */
    sendJoinSignal() {
        this.sendSignal({
            msg: {
                cmd: "Collaboration.UserJoined"
            }
        });
    }

    setupClient(remoteClient) {
        let client = this.getClient(remoteClient);

        if(client.style == null) {
            client.style = document.createElement("style");
        }

        let colorArray = Array.from(this.availableColors.values());
        let random = Math.floor(Math.random() * colorArray.length);
        let color = colorArray[random];
        this.availableColors.delete(color);

        client.color = color;

        client.style.innerHTML = `
.otherCursor_${remoteClient}::before {
    background-color: hsl(${color}, 100%, 65%);
}

.otherSelection_${remoteClient} {
    background-color: hsla(${color}, 100%, 50%, 0.1);
}`

        this.styleTransient.appendChild(client.style);
    }

    getClientIcon(remoteClient) {
        let client = this.getClient(remoteClient);

        let icon = WebstrateComponents.Tools.loadTemplate("Collaboration_icon");
        cQuery(icon).one("#initials").appendChild(document.createTextNode(client.info.userName.substring(0, 2)));
        cQuery(icon).one("#name").appendChild(document.createTextNode(client.info.userName));
        if(client.info.avatar != null) {
            cQuery(icon).one("image").setAttribute("href", client.info.avatar);
        } else {
            cQuery(icon).one("image").remove();
        }
        icon.style.color = `hsl(${client.color}, 100%, 15%)`;
        icon.style.fill = `hsl(${client.color}, 100%, 75%)`;
        icon.classList.add("collaboration-client-icon");
        return icon;
    }

    handleFragmentFound(fragmentElement) {
        let self = this;

        let fragment = cQuery(fragmentElement).data("Fragment");

        //Setup fragment listening of clients
        fragmentElement.webstrate.on("signal", (msg, sender)=>{
            if(sender === webstrate.clientId) {
                //Skip self
                return;
            }

            let client = self.getClient(sender);

            if(msg.cmd === "Collaboration.Fragment.Selection" || msg.cmd === "Collaboration.Fragment.Focused") {
                if(client.focusFragment !== fragment) {
                    client.focusFragment = fragment;
                    EventSystem.triggerEvent("Collaboration.FragmentFocused", {
                        client: client,
                        fragment: fragment
                    });
                }

                if(msg.selection != null) {
                    client.selection = msg.selection;
                    EventSystem.triggerEvent("Collaboration.FragmentSelection", {
                        client: client,
                        fragment: fragment,
                        selection: msg.selection
                    });
                }
            } else if(msg.cmd === "Collaboration.Fragment.Unfocused") {
                if(client.focusFragment === fragment) {
                    client.focusFragment = null;
                    EventSystem.triggerEvent("Collaboration.FragmentUnfocused", {
                        client: client,
                        fragment: fragment
                    });
                }
            }
        });
    }

    setupObserver() {
        let self = this;

        this.observer = new MutationObserver((mutations)=>{
            mutations.forEach((mutation)=>{
                Array.from(mutation.addedNodes).forEach((addedNode)=>{
                    if(addedNode.matches != null && addedNode.matches("code-fragment")) {
                        self.handleFragmentFound(addedNode);
                    }

                    if(addedNode.querySelectorAll != null) {
                        addedNode.querySelectorAll("code-fragment").forEach((fragment)=>{
                            self.handleFragmentFound(fragment);
                        });
                    }
                });
            });
        });

        this.observer.observe(document, {
            childList: true,
            subtree: true
        });
    }

    //Get a color from a HSL divided spectrum
    static selectColor(colorNum, colors){
        if (colors < 1) colors = 1; // defaults to one color - avoid divide by zero
        return (colorNum * (360 / colors) % 360);
    }
}

if (typeof webstrate !== "undefined"){
    // We only support collaboration with a webstrates server backend
    Cauldron.Collaboration = new Collaboration(16);

    //Signal everyon on the webstrate that we are here, and who we are
    Cauldron.Collaboration.sendJoinSignal();
    Cauldron.Collaboration.sendUserInfoSignal();
}

</script>

                <template id="Collaboration_icon">
<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title id='name'></title>
    <defs>
        <linearGradient id="g" x1="0%" y1="0%" x2="0%" y2="100%">
          <stop offset="60%" stop-color="#EEE" />
          <stop offset="90%" stop-color="#000" />
        </linearGradient>        
        <mask id="m">  
            <rect x="0" y="0" width="100" height="100" fill="url(#g)"  />  
        </mask>  
        <clipPath id="c"><circle cx="50" cy="50" r="44" fill="#FFF" /></clipPath>
     </defs>
    <circle cx="50" cy="50" r="47" stroke-width="6" stroke="currentColor" />
    <image mask="url(#m)" opacity="0.5" preserveAspectRatio="xMidYMid slice" clip-path="url(#c)" x="3" y="3" width="94" height="94" xlink:href="" />
    <text id="initials" font-size="55" x="50%" y="50%" fill="currentColor" stroke="currentColor" dominant-baseline="central" text-anchor="middle" stroke-width="3"></text>  
</svg>    
</template>

                <style id="main-style">
/**
 *  Collaboration Styles
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
.cauldron-editor-component-clientarea {
  display: flex; }
  .cauldron-editor-component-clientarea .collaboration-client-icon {
    margin-left: -0.4em; }

.collaboration-client-icon {
  width: 1.5em;
  height: 1.5em;
  transition: transform 0.1s ease-out;
  user-select: none; }
  .collaboration-client-icon:hover {
    transform: scale(1.1); }
</style>

            </div>
            
            <div class="package" id="CauldronLauncher">
                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "Cauldron Launcher",
    "description": "Delayed-loads the newest (or included) version of Cauldron and adds it to the window object",
    "dependencies": [
        "#CauldronNamespace"
    ],
    "optionalDependencies": [
        "#Cauldron"
    ],    
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",    
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <script id="cauldron-launcher-script" type="disabled">
/**
 *  CauldronLauncher
 *  Launch Cauldron with delayed-load feature or directly if preloaded
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

// Create function on window to install Cauldron editor
window.cauldronEditor = async () => {
    if(typeof Cauldron === "undefined" || typeof Cauldron.Cauldron === "undefined") {
        await WPMv2.require({package: "Cauldron", repository: "cauldron-repos"});
    }
    if(typeof localCauldronEditor === "undefined") {
        window.localCauldronEditor = new Cauldron.Cauldron();
    }
    localCauldronEditor.open();
};

</script>

            </div>            
            <div class="package" id="CauldronButtonLauncher">
                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "Cauldron Edit Button",
    "description": "A floating edit button on your page that launches Cauldron",
    "dependencies": [
        "#CauldronLauncher"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",    
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <script id="button-launcher-script" type="disabled">
// Add edit button to page that opens up the Cauldron editor
let button = document.createElement("button");
button.innerHTML="Edit"
button.style.position = "fixed";
button.style.top = "1em";
button.style.right = "1em";
button.id = "cauldron-edit-button";

let transientElement = document.createElement("transient");
transientElement.append(button);
document.body.appendChild(transientElement);

button.addEventListener("click", ()=>{
    cauldronEditor();
});


</script>

            </div>            
            <div class="package" id="CauldronAutoLauncher">
                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "Cauldron Auto Launcher",
    "description": "Launches Cauldron automatically on load",
    "dependencies": [
        "#CauldronLauncher"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",    
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <script id="auto-launcher-script" type="disabled">
wpm.onAllInstalled(()=>{
    // Just DO it!
    cauldronEditor();
});

</script>

            </div>                  
            <div class="package" id="CauldronURLLauncher">
                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "Cauldron Edit URL",
    "description": "Launches Cauldron when ?edit is added to the URL of the page, also adds the Popup option to the Views menu",
    "dependencies": [
        "#CauldronLauncher",
        "codestrates-repos #EventSystem"
    ],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",    
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <script id="url-launcher-script" type="disabled">
/**
 *  URL Launcher
 *  Launched Cauldron when a specific URL pattern is detected
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

// Launch Cauldron when ?edit is added to the URL
const urlParams = new URLSearchParams(window.location.search);
const editorMode = urlParams.get('edit');

if(editorMode != null && editorMode !== false) {
    // Be nice to Codestrates if it is running
    if (window.Fragment){
        Fragment.disableAutorun = true;
    }
    
    EventSystem.registerEventCallback("Cauldron.OnInit", ({detail: {cauldron: cauldron}})=>{
        EventSystem.triggerEvent("Cauldron.Dock", {
            pos: EdgeDocker.MODE.MAXIMIZED
        });
    });
    
    cauldronEditor();
}


//Run when/if Cauldron is initialized
if (typeof webstrate !== "undefined"){
    EventSystem.registerEventCallback("Cauldron.OnInit", ()=>{
        //Insert Cauldron view menu item
        MenuSystem.MenuManager.registerMenuItem("Cauldron.View.Dock", {
            label: "Popout editor",
            icon: IconRegistry.createIcon("mdc:open_in_new"),        
            order: 1000, //Order us very low priority, so near the end of the menu
            onAction: ()=>{
                window.open(location.href+"?edit");
            }
        });
    });
}

</script>

            </div>                              
        </div>
    </body>
</html>

